section.ly-section.md-markdown
  :ultramarked
    # API Documentation

    Here's the API documentation for Taunus. If you've never used it before, we recommend going over the [Getting Started][1] guide before jumping into the API documentation. That way, you'll get a better idea of what to look for and how to put together simple applications using Taunus, before going through documentation on every public interface to Taunus.

    Taunus exposes _three different public APIs_, and there's also **plugins to integrate Taunus and an HTTP server**. This document covers all three APIs extensively. If you're concerned about the inner workings of Taunus, please refer to the [Getting Started][1] guide. This document aims to only cover how the public interface affects application state, but **doesn't delve into implementation details**.

    # Table of Contents

    - A [server-side API](#server-side-api) that deals with server-side rendering
      - The [`taunus.mount`](#-taunus-mount-addroute-options-) method
        - Its [`options`](#the-options-object) argument
          - [`layout`](#-options-layout-)
          - [`routes`](#-options-routes-)
          - [`getDefaultViewModel`](#-options-getdefaultviewmodel-)
          - [`plaintext`](#-options-plaintext-)
          - [`resolvers`](#-options-resolvers-)
          - [`version`](#-options-version-)
          - [`deferMinified`](#-options-deferminified-)
        - Its [`addRoute`](#-addroute-definition-) argument
      - The [`taunus.render`](#-taunus-render-action-viewmodel-req-res-next-) method
      - The [`taunus.resolve`](#-taunus-resolve-action-data-) method
      - The [`taunus.redirect`](#-taunus-redirect-req-res-url-options-) method
      - The [`taunus.rebuildDefaultViewModel`](#-taunus-rebuilddefaultviewmodel-done-) method
    - [Server-side controllers](#server-side-controllers)
    - A [suite of plugins](#http-framework-plugins) can integrate Taunus and an HTTP server
      - Using [`taunus-express`](#using-taunus-express-) for [Express][2]
      - Using [`taunus-hapi`](#using-taunus-hapi-) for [Hapi][3]
    - A [CLI that produces a wiring module](#command-line-interface) for the client-side
      - The [`--output`](#-output-) flag
      - The [`--watch`](#-watch-) flag
      - The [`--transform <module>`](#-transform-module-) flag
      - The [`--defer`](#-defer-actions-) flag
      - The [`--resolvers <module>`](#-resolvers-module-) flag
      - The [`--bundle`](#-bundle-) flag
    - A [client-side API](#client-side-api) that deals with client-side rendering
      - The [`taunus.mount`](#-taunus-mount-container-wiring-options-) method
        - Using the [`auto`](#using-the-auto-strategy) strategy
        - Using the [`inline`](#using-the-inline-strategy) strategy
        - Using the [`manual`](#using-the-manual-strategy) strategy
        - [Caching](#caching)
        - [Prefetching](#prefetching)
        - [Versioning](#versioning)
      - The [`taunus.on`](#-taunus-on-type-fn-) method
      - The [`taunus.once`](#-taunus-once-type-fn-) method
      - The [`taunus.off`](#-taunus-off-type-fn-) method
      - The [`taunus.intercept`](#-taunus-intercept-action-fn-) method
      - The [`taunus.partial`](#-taunus-partial-container-action-model-) method
      - The [`taunus.navigate`](#-taunus-navigate-url-options-) method
      - The [`taunus.route`](#-taunus-route-url-) method
        - The [`taunus.route.equals`](#-taunus-route-equals-route-route-) method
      - The [`taunus.redirect`](#-taunus-redirect-options-) method
      - The [`taunus.resolve`](#-taunus-resolve-on-the-client) method
      - The [`taunus.state`](#-taunus-state-) property
      - The [`taunus.xhr`](#-taunus-xhr-url-options-done-) method
      - The [`taunus.prefetch`](#using-taunus-prefetch-url-element-) method
      - [Debugging Taunus](#debugging-taunus)
    - [Client-side controllers](#client-side-controllers)
    - The [`.taunusrc`](#the-taunusrc-manifest) manifest

    # Server-side API

    The server-side API is used to set up the view router. It then gets out of the way, allowing the client-side to eventually take over and add any extra sugar on top, _including client-side rendering_.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.mount(addRoute, options?)`

    Mounts Taunus on top of a server-side router, by registering each route in `options.routes` with the `addRoute` method.

    > Note that most of the time, **this method shouldn't be invoked directly**, but rather through one of the [HTTP framework plugins](#http-framework-plugins) presented below.

    Here's an incomplete example of how this method may be used. It is incomplete because route definitions have more options beyond the `route` and `action` properties.

    ```js
    'use strict';

    taunus.mount(addRoute, {
      routes: [{ route: '/', action: 'home/index' }]
    });

    function addRoute (definition) {
      app.get(definition.route, definition.action);
    }
    ```

    Let's go over the options you can pass to `taunus.mount` first.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### The `options?` object

    There's a few options that can be passed to the server-side mountpoint. You're probably going to be passing these to your [HTTP framework plugin](#http-framework-plugins), rather than using `taunus.mount` directly.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.layout?`

    The `layout` property is expected to have the `function(data)` signature. It'll be invoked whenever a full HTML document needs to be rendered, and a `data` object will be passed to it. That object will contain everything you've set as the view model, plus a `partial` property containing the raw HTML of the rendered partial view. Your `layout` method will typically wrap the raw HTML for the partial with the bare bones of an HTML document. Check out [the `layout.jade` used in Pony Foo][4] as an example.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.routes`

    The other big option is `routes`, which expects a collection of route definitions. Route definitions use a number of properties to determine how the route is going to behave.

    Here's an example route that uses the [Express][2] routing scheme.

    ```js
    {
      route: '/articles/:slug',
      action: 'articles/article',
      ignore: false,
      cache: <inherit>
    }
    ```

    - `route` is a route in the format your HTTP framework of choice understands
    - `action` is the name of your controller action. It'll be used to find the server-side controller, the default view that should be used with this route, and the client-side controller
    - `cache` can be used to determine the client-side caching behavior in this application path, and it'll default to inheriting from the options passed to `taunus.mount` _on the client-side_
    - `ignore` is used in those cases where you want a URL to be ignored by the client-side router even if there's a catch-all route that would match that URL

    As an example of the `ignore` use case, consider the routing table shown below. The client-side router doesn't know _(and can't know unless you point it out)_ what routes are server-side only, and it's up to you to point those out.

    ```js
    [
      { route: '/', action: '/home/index' },
      { route: '/feed', ignore: true },
      { route: '/*', action: 'error/not-found' }
    ]
    ```

    This step is necessary whenever you have an anchor link pointed at something like an RSS feed. The `ignore` property is effectively telling the client-side _"don't hijack links containing this URL"_.

    Please note that external links are never hijacked. Only same-origin links containing a URL that matches one of the routes will be hijacked by Taunus. External links don't need to be `ignore`d.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.getDefaultViewModel?`

    The `getDefaultViewModel(done)` property can be a method that puts together the base view model, which will then be extended on an action-by-action basis. When you're done creating a view model, you can invoke `done(null, model)`. If an error occurs while building the view model, you should call `done(err)` instead.

    Taunus will throw an error if `done` is invoked with an error, so you might want to put safeguards in place as to avoid that from happenning. The reason this method is asynchronous is because you may need database access or somesuch when putting together the defaults. The reason this is a method and not just an object is that the defaults may change due to human interaction with the application, and in those cases [the defaults can be rebuilt](#taunus-rebuilddefaultviewmodel).

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.plaintext?`

    The `plaintext` options object is passed directly to [hget][5], and it's used to [tweak the plaintext version][6] of your site.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.resolvers?`

    Resolvers are used to determine the location of some of the different pieces of your application. Typically you won't have to touch these in the slightest.

    Signature                     | Description
    ------------------------------|------------------------------------------------------
    `getServerController(action)` | Return path to server-side controller action handler module
    `getView(action)`             | Return path to view template module

    The `addRoute` method passed to `taunus.mount` on the server-side is mostly going to be used internally by the HTTP framework plugins, so feel free to skip over the following section.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.version?`

    Refer to the [Versioning](#versioning) section.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.getPartial?`

    By default, Taunus will render partials on the server-side by looking up the module for an action method, and calling that action passing in a model.

    You can override the default behavior by setting `options.getPartial` to a function. This method takes three parameters.

    - `action` is the action that needs to be rendered
    - `model` is the model you can use to render the view for that action
    - `done(err, html)` is called when you're done, passing in the resulting `html` for the partial

    Note that if you don't set `getPartial`, Taunus will just require your controller action method and invoke that instead.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ###### `options.deferMinified?`

    When views and controllers are lazily loaded, they are compiled and bundled using Browserify. Taunus will even produce a source map. To avoid the source map, and minify the bundle instead, set `deferMinified` to `true`.

    You'll probably want to set `deferMinified` to whether the application is running on the production environment.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### `addRoute(definition)`

    The `addRoute(definition)` method will be passed a route definition, containing the following properties. This method is expected to register a route in your HTTP framework's router.

    - `route` is the route that you set as `definition.route`
    - `action` is the action as passed to the route definition
    - `actionFn` will be the controller for this action method
    - `middleware` will be an array of methods to be executed before `actionFn`

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.render(action, viewModel, req, res, next)`

    This method is almost an implementation detail as you should be using Taunus through one of the plugins anyways, so we won't go very deep into it.

    The render method is what Taunus uses to render views by constructing HTML, JSON, or plaintext responses. The `action` property determines the default view that will be rendered. The `viewModel` will be extended by [the default view model](#-options-getdefaultviewmodel-), and it may also override the default `action` by setting `viewModel.model.action`.

    The `req`, `res`, and `next` arguments are expected to be the Express routing arguments, but they can also be mocked _(which is in fact what the Hapi plugin does)_.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.rebuildDefaultViewModel(done?)`

    Once Taunus has been mounted, calling this method will rebuild the view model defaults using the `getDefaultViewModel` that was passed to `taunus.mount` in the options. An optional `done` callback will be invoked when the model is rebuilt.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.resolve(action, data?)`

    Returns the first route that matches an `action`, replacing named parameters with data from the `data` object. If a matching route is not found, `null` is returned.

    > If a route is matched but a required named parameter isn't in `data`, **an exception will be thrown**.

    This method is most useful when composing the URL for a redirect or an action link within a template, as a means to keep the route declaration isolated from the route itself. If the route changes, the method will reflect the newer route as long as the parameters stay the same, resulting in increased maintainability. _The method is available in both layout templates and partial view templates._

    ###### Example

    ```js
    taunus.resolve('projects/project', {
      name: 'puppies', organization: 'caniuse'
    });
    // <- /p/caniuse/puppies
    ```

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.redirect(req, res, url, options?)`

    Redirects the response to a different URL. If the request accepts HTML, this method is equivalent to `res.redirect(url)`. If the request accepts JSON, a specially crafted JSON response will trigger a client-side redirect using [taunus.navigate](#-taunus-navigate-url-options-).

    Option  | Description
    --------|--------------------------------------------------------------------------------
    `hard`  | Uses a full page redirect when `true`
    `force` | Client-side redirects will be carried out even if the target URL is the same as the current `location`

    ###### Example

    ```js
    taunus.redirect(req, res, '/login');
    ```

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # Server-Side Controllers

    On the server-side, controllers are modules that export a single function. The parameters passed to these controllers depend on the server-side HTTP framework that's being used.

    For example, Express gives us three parameters: `req`, `res` and `next`. Hapi gives us two instead: `request` and `reply`.

    Here's a sample controller using `taunus-express`, as [detailed below](#using-taunus-express-). This is a very simple controller where we are setting the special `viewModel` property on the response, and calling `next`. Suppose this controller is the `product/home` action handler.

    ```js
    module.exports = function (req, res, next) {
      res.viewModel = {
        model: {
          title: 'view title'
        }
      };
      next();
    };
    ```

    As you can see, Taunus won't alter the API provided by Express. Instead, it builds upon the notion of using middleware. Once the `product/home` view is rendered and JavaScript loads, the `product/home` view controller is executed on the client-side.

    You could change the view to be rendered by setting the `action` property on the `model`. In the example shown below this would mean that the `error/offline` view would be rendered. The client-side controller will be that of `error/offline`, as well. View controllers are tied to the view that gets rendered.

    ```js
    module.exports = function (req, res, next) {
      res.viewModel = {
        model: {
          title: 'view title'
        }
      };
      if (offline) {
        res.viewModel.model.action = 'error/offline';
      }
      next();
    };
    ```

    Having a default action and the ability to redirect to another gives us a lot of flexibility when determining how to respond to a request.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # HTTP Framework Plugins

    There's currently two different HTTP frameworks _([Express][2] and [Hapi][3])_ that you can readily use with Taunus without having to deal with any of the route plumbing yourself.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## Using `taunus-express`

    The `taunus-express` plugin is probably the easiest to use, as Taunus was originally developed with just [Express][2] in mind. In addition to the options already outlined for [taunus.mount](#-taunus-mount-addroute-options-), you can add middleware for any route individually.

    - `middleware` are any methods you want Taunus to execute as middleware in Express applications

    To get `taunus-express` going you can use the following piece of code, provided that you come up with an `options` object.

    ```js
    'use strict';

    var taunus = require('taunus');
    var taunusExpress = require('taunus-express');
    var express = require('express');
    var app = express();
    var options = {
      // ...
    };

    taunusExpress(taunus, app, options);
    ```

    The `taunusExpress` method will merely set up Taunus and add the relevant routes to your Express application by calling `app.get` a bunch of times. You can [find taunus-express on GitHub][7].

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## Using `taunus-hapi`

    The `taunus-hapi` plugin is a bit more involved, and you'll have to create a Pack in order to use it. In addition to [the options we've already covered](#-taunus-mount-addroute-options-), you can add `config` on any route.

    - `config` is passed directly into the route registered with Hapi, giving you the most flexibility

    To get `taunus-hapi` going you can use the following piece of code, and you can bring your own `options` object.

    ```js
    'use strict';

    var Hapi = require('hapi');
    var taunus = require('taunus');
    var taunusHapi = require('taunus-hapi')(taunus);
    var pack = new Hapi.Pack();

    pack.register({
      plugin: taunusHapi,
      options: {
        // ...
      }
    });
    ```

    The `taunusHapi` plugin will mount Taunus and register all of the necessary routes. You can [find taunus-hapi on GitHub][8].

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # Command-Line Interface

    Once you've set up the server-side to render your views using Taunus, it's only logical that you'll want to render the views in the client-side as well, effectively converting your application into a single-page application after the first view has been rendered on the server-side.

    The Taunus CLI is an useful intermediary in the process of getting the configuration you wrote so far for the server-side to also work well in the client-side.

    Install it globally for development, but remember to use local copies for production-grade uses.

    ```shell
    npm install -g taunus
    ```

    When invoked without any arguments, the CLI will simply follow the default conventions to find your route definitions, views, and client-side controllers.

    ```shell
    taunus
    ```

    By default, the output will be printed to the standard output, making for a fast debugging experience. Here's the output if you just had a single `home/index` route, and the matching view and client-side controller existed.

    ```js
    'use strict';

    var templates = {
      'home/index': require('./views/home/index.js')
    };

    var controllers = {
      'home/index': require('../client/js/controllers/home/index.js')
    };

    var routes = [
      {
        route: '/',
        action: 'home/index'
      }
    ];

    module.exports = {
      templates: templates,
      controllers: controllers,
      routes: routes
    };
    ```

    You can use a few options to alter the outcome of invoking `taunus`.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--output`

    <sub>the `-o` alias is available</sub>

    Output is written to a file instead of to standard output. The file path used will be the `client_wiring` option in [`.taunusrc`](#the-taunusrc-manifest), which defaults to `'.bin/wiring.js'`.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--watch`

    <sub>the `-w` alias is available</sub>

    Whenever a server-side route definition changes, the output is printed again to either standard output or a file, depending on whether `--output` was used.

    The program won't exit.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--transform <module>`

    <sub>the `-t` alias is available</sub>

    This flag allows you to transform server-side routes into something the client-side understands. Express routes are completely compatible with the client-side router, but Hapi routes need to be transformed using the [`hapiify`][9] module.

    ```shell
    npm install hapiify
    taunus -t hapiify
    ```

    Using this transform relieves you from having to define the same routes twice using slightly different formats that convey the same meaning.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--defer [actions]`

    <sub>the `-d` alias is available</sub>

    Here is where things get interesting. The `--defer` flag allows you to defer loading for zero or more actions. Excluding the controller and view templates for any deferred action can significantly reduce the fingerprint of your application.

    The `[actions]` argument determines what actions get deferred, and which don't. It expects a comma-separated list of actions, where you can pass in either the controller name, or both the controller name and the action name. Using `?` acts as a wildcard.

    For example, using `admin` _(equivalent to using `admin/?`)_ will defer every action under the `admin` controller. Using `admin/nuke` will only defer the `admin/nuke` action. If you omit the `[actions]` parameter entirely, the default value of `'?'` will be used and everything will be deferred.

    When components get deferred, they'll be loaded as soon as Taunus detects that they're needed. This can happen in a few places.

    - The user navigates to (or [_prefetches_](#prefetching)) the `/admin` route, and `admin/index` was deferred, and its components aren't cached on the client-side yet
    - A controller uses `taunus.partial` to render an action that was deferred, and its components aren't cached on the client-side yet
    - The user navigates to the `/admin` route, and its matching `admin/index` route wasn't deferred, but the server-side controller decides to change the action to `admin/superadmin`. When the response gets to the client, it'll need to ask the server for the `admin/superadmin` template if the client doesn't already have it

    You don't have to worry about those different scenarios, though, as Taunus handles them all for you transparently. You should [learn more about deferred loading on the Performance Optimization guide][20].

    > A possible concern with deferred execution is that partial views may not be rendered immediately, as a request may be necessary to fetch the controller or template for the partial.

    Some other considerations, regarding how deferred components get bundled, are listed in the [Performance Optimization][20] guide.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--resolvers <module>`

    <sub>the `-r` alias is available</sub>

    Similarly to the [`resolvers`](#-options-resolvers-) option that you can pass to [`taunus.mount`](#-taunus-mount-addroute-options-), these resolvers can change the way in which file paths are resolved.

    Signature                     | Description
    ------------------------------|------------------------------------------------------
    `getClientController(action)` | Return path to client-side controller action handler module
    `getView(action)`             | Return path to view template module

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `--bundle`

    <sub>the `-b` alias is available</sub>

    Under this experimental flag, the CLI will use Browserify to compile a standalone module that includes the wiring normally exported by the CLI plus all of Taunus [as a UMD module][10].

    This allows you to use Taunus on the client-side even if you don't want to use [Browserify][11] directly.

    Feedback and suggestions about this flag, _and possible alternatives that would make Taunus easier to use_, are welcome.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # Client-side API

    Just like the server-side, everything in the client-side begins at the mountpoint. Once the application is mounted, anchor links will be hijacked and the client-side router will take over view rendering. Client-side controllers are executed whenever a view is rendered.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.mount(container, wiring, options?)`

    The mountpoint takes a root container, the wiring module, and an options parameter. The `container` is where client-side-rendered views will be placed, by replacing whatever HTML contents already exist. You can pass in the `wiring` module exactly as built by the CLI, and no further configuration is necessary.

    When the mountpoint executes, Taunus will configure its internal state, _set up the client-side router_, run the client-side controller for the server-side rendered view, and start hijacking links.

    As an example, consider a browser makes a `GET` request for `/articles/the-fox` for the first time. Once `taunus.mount(container, wiring)` is invoked on the client-side, several things would happen in the order listed below.

    - Taunus sets up the client-side view routing engine
    - If enabled _(via `options`)_, the caching engine is configured
    - Taunus obtains the view model _(more on this later)_
    - When a view model is obtained, the `'start'` event is emitted
    - Anchor links start being monitored for clicks _(at this point your application becomes a [SPA][13])_
    - The `articles/article` client-side controller is executed

    That's quite a bit of functionality, but if you think about it, most other frameworks also render the view at this point, _rather than on the server-side!_

    In order to better understand the process, I'll walk you through the `options` parameter.

    First off, the `bootstrap` option determines the strategy used to pull the view model of the server-side rendered view into the client-side. There are three possible strategies available: `auto` _(the default strategy)_, `inline`, or `manual`. The `auto` strategy involves the least work, which is why it's the default.

    - `auto` will make an AJAX request for the view model
    - `inline` expects you to place the model into a `<script type='text/taunus'>` tag
    - `manual` expects you to get the view model however you want to, and then let Taunus know when it's ready

    Let's go into detail about each of these strategies.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### Using the `auto` strategy

    The `auto` strategy means that Taunus will make use of an AJAX request to obtain the view model. _You don't have to do anything else_ and this is the default strategy. This is the **most convenient strategy, but also the slowest** one.

    It's slow because the view model won't be requested until the bulk of your JavaScript code has been downloaded, parsed, executed, and `taunus.mount` is invoked.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### Using the `inline` strategy

    The `inline` strategy expects you to add a `data-taunus` attribute on the `container` element. This attribute must be equal to the `id` attribute of a `<script>` tag containing the serialized view model alongside the version information automatically injected by Taunus into the layout template data.

    ```jade
    div(data-taunus='model')!=partial
    script#model(type='text/taunus')=JSON.stringify({ version: version, model: model })
    ```

    Pay special attention to the fact that the model is not only made into a JSON string, _but also HTML encoded by Jade_. When Taunus extracts the model from the `<script>` tag it'll unescape it, and then parse it as JSON.

    This strategy is also fairly convenient to set up, but it involves a little more work. It might be worthwhile to use in cases where models are small, but it will slow down server-side view rendering, as the model is inlined alongside the HTML.

    That means that the content you are supposed to be prioritizing is going to take longer to get to your humans, but once they get the HTML, this strategy will execute the client-side controller almost immediately.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### Using the `manual` strategy

    The `manual` strategy is the most involved of the three, but also the most performant. In this strategy you're supposed to add the following _(seemingly pointless)_ snippet of code in a `<script>` other than the one that's pulling down Taunus, so that they are pulled concurrently rather than serially.

    ```js
    'use strict';

    window.taunusReady = function (model) {
      window.taunusReady = model;
    };
    ```

    Once you somehow get your hands on the view model, you should invoke `taunusReady(model)`. Considering you'll be pulling both the view model and Taunus at the same time, a number of different scenarios may play out.

    - The view model is loaded first, you call `taunusReady(model)` and wait for Taunus to take the model object and boot the application as soon as `taunus.mount` is executed
    - Taunus loads first and `taunus.mount` is called first. In this case, Taunus will replace `window.taunusReady` with a special `boot` method. When the view model finishes loading, you call `taunusReady(model)` and the application finishes booting

    > If this sounds a little mind-bending it's because it is. It's not designed to be pretty, but merely to be performant.

    Now that we've addressed the awkward bits, let's cover the _"somehow get your hands on the view model"_ aspect. My preferred method is using JSONP, as it's able to deliver the smallest snippet possible, and it can take advantage of server-side caching. Considering you'll probably want this to be an inline script, keeping it small is important.

    The good news is that the server-side supports JSONP out the box. Here's a snippet of code you could use to pull down the view model and boot Taunus up as soon as both operations are ready.

    ```js
    'use strict';

    function inject (url) {
      var script = document.createElement('script');
      script.src = url;
      document.body.appendChild(script);
    }

    function injector () {
      var search = location.search;
      var searchQuery = search ? '&' + search.substr(1) : '';
      var searchJson = '?json&callback=taunusReady' + searchQuery;
      inject(location.pathname + searchJson);
    }

    window.taunusReady = function (model) {
      window.taunusReady = model;
    };

    injector();
    ```

    As mentioned earlier, this approach involves getting your hands dirtier but it pays off by being the fastest of the three.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### Caching

    The client-side in Taunus supports caching in-memory and using the embedded IndexedDB system by merely turning on the `cache` flag in the options passed to `taunus.mount` on the client-side.

    If you set `cache` to `true` then cached items will be considered _"fresh" (valid copies of the original)_ for **15 seconds**. You can also set `cache` to a number, and that number of seconds will be used as the default instead.

    Caching can also be tweaked on individual routes. For instance, you could set `{ cache: true }` when mounting Taunus and then have `{ cache: 3600 }` on a route that you want to cache for a longer period of time.

    The caching layer is _seamlessly integrated_ into Taunus, meaning that any views rendered by Taunus will be cached according to these caching rules. Keep in mind, however, that persistence at the client-side caching layer will only be possible in [browsers that support IndexedDB][14]. In the case of browsers that don't support IndexedDB, Taunus will use an in-memory cache, which will be wiped out whenever the human decides to close the tab in their browser.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### Prefetching

    If caching is enabled, the next logical step is prefetching. This is enabled just by adding `prefetch: true` to the options passed to `taunus.mount`. The prefetching feature will fire for any anchor link that's trips over a `mouseover` or a `touchstart` event. If a route matches the URL in the `href`, an AJAX request will prefetch the view and cache its contents, improving perceived performance.

    When links are clicked before prefetching finishes, they'll wait on the prefetcher to finish before immediately switching to the view, effectively cutting down the response time. If the link was already prefetched or otherwise cached, the view will be loaded immediately. If the human hovers over a link and another one was already being prefetched, then that one is aborted. This prevents prefetching from draining the bandwidth on clients with limited or intermittent connectivity.

    #### Versioning

    When enabled, versioning will look out for discrepancies between what's currently on the client and what's on the server, and reload everything necessary to make what's on the client match what's on the server.

    In order to turn it on, set the `version` field in the options when invoking `taunus.mount` **on both the server-side and the client-side, using the same value**. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.

    > To make sure you don't forget to change the version string in one of the mountpoints, please create a JSON file with just the version string and `require` that file in both sides.
    >
    > ```shell
    > echo '"1.0.0"' > version.json
    > ```

    The default version string is set to `1`. The Taunus version will be prepended to yours, resulting in a value such as `t3.0.0;v1` where Taunus is running version `3.0.0` and your application is running version `1`.

    Refer to the Getting Started guide for a more detailed [analysis of the uses for versioning][15]. There's some more nuggets of information in the [Performance Optimization][18] guide as well.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.on(type, fn)`

    Taunus emits a series of events during its lifecycle, and `taunus.on` is the way you can tune in and listen for these events using a subscription function `fn`.

    Event            | Arguments                 | Description
    -----------------|---------------------------|------------------------------------
    `'start'`        | `container, model, route` | Emitted when `taunus.mount` finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling `taunus.mount`.
    `'render'`       | `container, model, route` | A view has just been rendered and its client-side controller is about to be invoked
    `'change'`       | `route, model`            | Same as `'render'`, but only if `container` is the mountpoint and the route has changed.
    `'fetch.start'`  |  `route, context`         | Emitted whenever an XHR request starts.
    `'fetch.done'`   |  `route, context, data`   | Emitted whenever an XHR request ends successfully.
    `'fetch.abort'`  |  `route, context`         | Emitted whenever an XHR request is purposely aborted.
    `'fetch.error'`  |  `route, context, err`    | Emitted whenever an XHR request results in an HTTP error.

    Consider for instance that you'd like to keep track of every view that gets rendered, and what DOM element it gets placed into. The piece of code below would quickly do that for us.

    ```js
    taunus.on('render', function (container) {
      console.log('Rendered a view on', container);
    });
    ```

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.once(type, fn)`

    This method is equivalent to [`taunus.on`](#-taunus-on-type-fn-), except the event listeners will be used once and then it'll be discarded.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.off(type, fn)`

    Using this method you can remove any event listeners that were previously added using `.on` or `.once`. You must provide the type of event you want to remove and a reference to the event listener function that was originally used when calling `.on` or `.once`.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.intercept(action?, fn)`

    This method can be used to anticipate model requests, before they ever make it into XHR requests. You can add interceptors for specific actions, which would be triggered only if the request matches the specified `action`. You can also add global interceptors by omitting the `action` parameter, or setting it to `*`.

    An interceptor function will receive an `event` parameter, containing a few different properties.

    - `url` contains the URL that needs a view model
    - `route` contains the full route object as you'd get from [`taunus.route(url)`](#-taunus-route-url-)
    - `parts` is just a shortcut for `route.parts`
    - `preventDefault(data)` allows you to suppress the need for an AJAX request, commanding Taunus to use the response data you've provided instead
    - `defaultPrevented` tells you if some other handler has prevented the default behavior
    - `canPreventDefault` tells you if invoking `event.preventDefault` will have any effect
    - `data` starts as `null`, and it can later become the data passed to `preventDefault`

    Interceptors are asynchronous, but if an interceptor spends longer than 50ms it'll be short-circuited and calling `event.preventDefault` past that point won't have any effect.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.partial(container, action, model)`

    This method provides you with access to the view-rendering engine of Taunus. You can use it to render the `action` view into the `container` DOM element, using the specified `model`. Once the view is rendered, the `render` event will be fired _(with `container, model` as arguments)_ and the client-side controller for that view will be executed.

    Note that the partial may be rendered asynchronously if the `action` is [deferred](#-defer-actions-) and its components (view template, controller) aren't readily available in the client yet. This method returns an event emitter, which you can use to guarantee that you continue exection after the partial has been rendered.

    #### Example

    Given a deferred `'tags'` partial view like this function:

    ```js
    function (model) {
      return model.length ? '<ul><li>' + model.join('</li><li>') + '</li></ul>' : '<ul></ul>';
    }
    ```

    You could render the view and continue execution once the view has been rendered onto a `div` by listening to the `'render'` event at the view level.

    ```js
    taunus.partial(div, 'tags', ['a', 'b']).on('render', function (html) {
      console.log('Here\'s the HTML that was rendered on our div\n' + html);
    });
    ```

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.navigate(url, options)`

    Whenever you want to navigate to a URL, say when an AJAX call finishes after a button click, you can use `taunus.navigate` passing it a plain URL or anything that would cause `taunus.route(url)` to return a valid route.

    By default, if `taunus.navigate(url, options)` is called with an `url` that doesn't match any client-side route, then the user will be redirected via `location.href`. In cases where the browser doesn't support the history API, `location.href` will be used as well.

    There's a few options you can use to tweak the behavior of `taunus.navigate`.

    Option           | Description
    -----------------|-------------------------------------------------------------------
    `context`        | A DOM element that caused the navigation event, used when emitting events
    `strict`         | If set to `true` and the URL doesn't match any route, then the navigation attempt must be ignored
    `scroll`         | When this is set to `false`, elements aren't scrolled into view after navigation
    `force`          | Unless this is set to `true`, navigation won't _fetch a model_ if the route matches the current route, and `state.model` will be reused instead
    `replaceState`   | Use `replaceState` instead of `pushState` when changing history

    Note that the notion of _fetching a model_ might be deceiving as the model could be pulled from the cache even if `force` is set to `true`.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.route(url)`

    This convenience method allows you to break down a URL into its individual components. The method accepts any of the following URL patterns, and it returns a Taunus route object.

    - A fully qualified URL on the same origin, e.g `http://taunus.io/api`
    - An absolute URL without an origin, e.g `/api`
    - Just a hash, e.g `#foo` _(`location.href` is used)_
    - Falsy values, e.g `null` _(`location.href` is used)_

    Relative URLs are not supported _(anything that doesn't have a leading slash)_, e.g `files/data.json`. Anything that's not on the same origin or doesn't match one of the registered routes is going to yield `null`.

    _This method is particularly useful when debugging your routing tables, as it gives you direct access to the router used internally by Taunus._

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    #### `taunus.route.equals(route, route)`

    Compares two routes and returns `true` if they would fetch the same model. Note that different URLs may still return `true`. For instance, `/foo` and `/foo#bar` would fetch the same model even if they're different URLs. That's because the hash portion of an URL is never sent to the server.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.redirect(options)`

    Redirects the user to a different URL. If `hard` is set to `true`, then this method is effectively the same as doing `location.href = options.href`. If `hard` is `false`, [taunus.navigate](#-taunus-navigate-url-options-) will be used.

    ###### Example

    ```js
    taunus.redirect({ href: '/foo', hard: true });
    ```

    When the `force` option is set to `true`, redirects will be carried out even if the target URL is the same as the current `location`.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.resolve` on the client

    This method is identical to the server-side flavor of [`taunus.resolve(action, data)`](#-taunus-resolve-action-data-), but available on the client-side.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.state`

    This is an internal state variable, and it contains a lot of useful debugging information.

    - `container` is the DOM element passed to `taunus.mount`
    - `controllers` are all the controllers, as defined in the wiring module
    - `templates` are all the templates, as defined in the wiring module
    - `routes` are all the routes, as defined in the wiring module
    - `route` is a reference to the current route
    - `model` is a reference to the model used to render the current view
    - `prefetch` exposes whether prefetching is turned on
    - `cache` exposes whether caching is enabled
    - `version` exposes the version string that's currently in use

    There's also a `clear` method accessible through `taunus.state.clear`, which will empty the cache, as well as remove from the `state` any controllers and templates that were lazy loaded.

    Of course, you're not supposed to meddle with it, so be a good citizen and just inspect its values!

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## `taunus.xhr(url, options?, done)`

    This method allows you to issue your own AJAX requests through the `xhr` module. It sets a few convenient defaults, _listed below_, where `url` refers to the URL passed as the first parameter.

    ```js
    {
      url: url,
      json: true,
      headers: { Accept: 'application/json' }
    }
    ```

    The `done(err, body, res)` callback will be invoked when the request finishes, and it'll be passed three parameters, an optional error if something went wrong _(request failed, was aborted, etc.)_ and a `body` parameter containing the response body. The raw `res` object that's typically provided by [`xhr`][16] as the second parameter is provided as the third parameter instead.

    As an example, here is a `GET` request.

    ```js
    taunus.xhr('/api/places', function (err, body) {
      console.log(body);
      // <- { places: ['underwater fortress', 'island mansion'] }
    });
    ```

    Always remember to handle the case where `err` is set!

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # Using `taunus.prefetch(url, element)`

    The prefetcher API allows you to start fetching an `url`, provided that it matches a known Taunus view route and that [the cache](#caching) is enabled. The `element` is used mostly as context during event emission, and it can be useful for debugging as well.

    Use cases for prefetching are further discussed in the [Performance Optimization][19] guide.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    ## Debugging Taunus

    On the client-side, you will typically `require` Taunus using the statement below.

    ```js
    var taunus = require('taunus');
    ```

    However, you could also turn on the internal debug logger simply by using another entry point!

    ```js
    var taunus = require('taunus/browser/debug');
    ```

    The screenshot below contains an example of this mechanism, where using [`taunus.partial`](#-taunus-partial-container-action-model-) triggers a flurry of debug messages.

    ![debug.png][17]

    This is particularly helpful during development, but also useful if you don't understand exactly how Taunus is doing something, as the logger is pretty verbose.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # Client-Side Controllers

    Client-side controllers are executed right after a view is rendered, even in the case of [partial views](#-taunus-partial-container-action-model-). These controllers are used to progressively add behavior on top of the HTML for that view.

    View controllers take three parameters.

    Parameter   | Description
    ------------|--------------------------
    `model`     | Model that was used to render the view
    `container` | The DOM element where the view was rendered
    `route?`    | Route that triggered the rendering engine. May be `null`

    Note that Taunus will [emit a `render` event](#-taunus-on-type-fn-) right before the view controller gets executed, giving you a chance to react to views getting rendered.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    # The `.taunusrc` manifest

    If you want to use values other than the conventional defaults shown in the table below, then you should create a `.taunusrc` file. Note that the defaults need to be overwritten in a case-by-case basis. These options can also be configured in your `package.json`, under the `taunus` property.

    ```json
    {
      "views": ".bin/views",
      "server_routes": "controllers/routes.js",
      "server_controllers": "controllers",
      "client_controllers": "client/js/controllers",
      "client_wiring": ".bin/wiring.js"
    }
    ```

    - The `views` directory is where your views _(already compiled into JavaScript)_ are placed. These views are used directly on both the server-side and the client-side
    - The `server_routes` file is the module where you export a collection of routes. The CLI will pull these routes when creating the client-side routes for the wiring module
    - The `server_controllers` directory is the root directory where your server-side controllers live. It's used when setting up the server-side router
    - The `client_controllers` directory is where your client-side controller modules live. The CLI will `require` these controllers in its resulting wiring module
    - The `client_wiring` file is where your wiring module will be placed by the CLI. You'll then have to `require` it in your application when booting up Taunus

    Here is where things get [a little conventional][12]. Views, and both server-side and client-side controllers are expected to be organized by following the `{root}/{controller}/{action}` pattern, but you could change that using `resolvers` when invoking the CLI and using the server-side API.

    Views and controllers are also expected to be CommonJS modules that export a single method.

    <sub>[_(back to table of contents)_](#table-of-contents)</sub>

    [1]: /getting-started
    [2]: http://expressjs.com
    [3]: http://hapijs.com
    [4]: https://github.com/ponyfoo/ponyfoo/blob/33271751312db6e92059d98293d0a7ac6e9e8e5b/views/server/layout/layout.jade
    [5]: https://github.com/bevacqua/hget
    [6]: https://github.com/ponyfoo/ponyfoo/blob/f6d6b5068ff03a387f503900160d9fdc1e749750/controllers/routing.js#L70-L72
    [7]: https://github.com/taunus/taunus-express
    [8]: https://github.com/taunus/taunus-hapi
    [9]: https://github.com/taunus/hapiify
    [10]: https://github.com/umdjs/umd
    [11]: http://browserify.org
    [12]: http://en.wikipedia.org/wiki/Convention_over_configuration
    [13]: http://en.wikipedia.org/wiki/Single-page_application
    [14]: http://caniuse.com/#feat=indexeddb
    [15]: /getting-started#versioning
    [16]: https://github.com/Raynos/xhr
    [17]: http://i.imgur.com/CjbIHy0.png
    [18]: /performance#use-versioning-to-ensure-cache-validity
    [19]: /performance#enable-prefetching-for-predictive-cache-loading
    [20]: /performance#send-views-and-controllers-to-the-client-selectively
