section.ly-section.md-markdown
  :ultramarked
    # Why Taunus?

    Taunus focuses on delivering a progressively enhanced experience to the end-user, while providing _a reasonable development experience_ as well. **Taunus prioritizes content**. It uses server-side rendering to get content to your humans as fast as possible, and it uses client-side rendering to improve their experience.

    While it focuses on progressive enhancement, **[usability][2] and performance are both core concerns** for Taunus. Incidentally, focusing on progressive enhancement also improves both of these. Usability is improved because the experience is gradually improved, meaning that if somewhere along the line a feature is missing, the component is **still expected to work**.

    For example, a progressively enhanced site uses plain-old links to navigate from one view to another, and then adds a `click` event handler that blocks navigation and issues an AJAX request instead. If JavaScript fails to load, perhaps the experience might stay a little bit worse, but that's okay, because we acknowledge that **our sites don't need to look and behave the same on every browser**. Similarly, [performance is greatly enhanced][1] by delivering content to the human as fast as possible, and then adding functionality on top of that.

    With progressive enhancement, if the functionality never gets there because a JavaScript resource failed to load because the network failed _(not uncommon in the mobile era)_ or because the user blocked JavaScript, your application will still work!

    [1]: http://ponyfoo.com/articles/critical-path-performance-optimization
    [2]: http://ponyfoo.com/articles/adjusting-ux-for-humans

section.ly-section.md-markdown
  :ultramarked
    # Why Not Other Frameworks?

    Many other frameworks weren't designed with progressive enhancement, or even shared-rendering in mind. Content isn't prioritized, and humans are expected to [download most of a web page before they can see any digestible content][2]. While Google is going to resolve the SEO issues with dedicated client-side rendering soon, that won't solve all your problems. Google isn't the only web crawler operator out there, and it might be a while before social media link crawlers catch up with them. Even if crawlers are not an issue, being able to provide the fastest possible experience is a big problem to resolve.

    Lately, many mature open-source frameworks started dropping support for older browsers. This is necessary because of the way they're architected, where the developer is put first. **Taunus is [#humanfirst][1]**, meaning that it concedes that humans are more important than the developers building their applications.

    Progressively enhanced applications are always going to have great browser support because of the way they're architected. As the name implies, a baseline is established where we deliver the core experience to the user _(typically in the form of readable HTML content)_, and then enhance it **if possible** using CSS and JavaScript. Building applications in this way means that **you'll be able to reach the most people with your core experience**, and you'll also be able to provide humans in more modern browsers with all of the latest features and technologies.

    [1]: https://twitter.com/hashtag/humanfirst
    [2]: http://ponyfoo.com/articles/stop-breaking-the-web

section.ly-section.md-markdown
  :ultramarked
    # Features

    Out of the box, Taunus ensures that your site works on any HTML-enabled document viewer, or even on the terminal, providing support for plain text responses [without any configuration needed][2]. Even while Taunus provides shared-rendering capabilities, it offers code reuse of views and routes, meaning you'll only have to declare these once but they'll be used in both the server-side and the client-side.

    Taunus features a reasonably enhanced experience, where if features aren't available on a browser, they're just not provided. For example, the client-side router makes use of the `history` API but if that's not available then it'll fall back to simply not meddling with links instead of using a client-side-only hash router.

    Taunus can deal with view caching on your behalf, if you so desire, using [asynchronous embedded database stores][3] on the client-side. Turns out, there's [pretty good browser support for IndexedDB][4]. Of course, IndexedDB will only be used if it's available, and if it's not then view models won't be cached in the client-side besides an in-memory store. **The site won't simply roll over and die, though.**

    If you've turned client-side caching on, then you can also turn on the **view pre-fetching feature**, which will start downloading views as soon as humans hover on links, as to deliver a _faster perceived human experience_.

    Taunus provides the bare bones for your application so that you can separate concerns into routes, controllers, models, and views. Then it gets out of the way, by design. There are [a few complementary modules][1] you can use to enhance your development experience, as well.

    With Taunus you'll be in charge. [Are you ready to get started?][2]

    [1]: /complements
    [2]: /getting-started
    [3]: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
    [4]: http://caniuse.com/#search=indexeddb

section.ly-section.md-markdown
  :ultramarked
    # Familiarity

    You can use Taunus to develop applications using your favorite Node.js HTTP server, **both [Express][3] and [Hapi][4] are fully supported**. In both cases, you'll [build controllers the way you're already used to][1], except you won't have to `require` the view controllers or define any view routes since Taunus will deal with that on your behalf. In the controllers you'll be able to do everything you're already able to do, and then you'll have to return a JSON model which will be used to render a view.

    You can use any view-rendering engine that you want, provided that it can be compiled into JavaScript functions. That's because Taunus treats views as mere JavaScript functions, rather than being tied into a specific view-rendering engine.

    Client-side controllers are just functions, too. You can bring your own selector engine, your own AJAX libraries, and your own data-binding solutions. It might mean there's a bit more work involved for you, but you'll also be free to pick whatever libraries you're most comfortable with! That being said, Taunus [does recommend a few libraries][2] that work well with it.

    [1]: /getting-started
    [2]: /complements
    [3]: http://expressjs.com
    [4]: http://hapijs.com
