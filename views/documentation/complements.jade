section.ly-section.md-markdown
  :ultramarked
    # Complementary Modules

    Taunus is a small library by MVC framework standards, sitting **below 15kB minified and gzipped**. It is designed to be small. It is also designed to do one thing well, and that's _being a shared-rendering MVC engine_.

    Taunus can be used for routing, putting together controllers, models and views to handle human interaction. If you [head over to the API documentation][1], you'll notice that the server-side API, the command-line interface, and the `.taunusrc` manifest are only concerned with providing a conventional shared-rendering MVC engine.

    In the server-side you might need to do other things besides routing and rendering views, and other modules can take care of that. However, you're used to having database access, search, logging, and a variety of services handled by separate libraries, instead of a single behemoth that tries to do everything.

    > In the client-side, you might be used to your MVC framework of choice resolving everything on your behalf, from DOM manipulation and data-binding to hooking up with a REST API, and everywhere in between.

    Taunus attempts to bring the server-side mentality of _"not doing everything is okay"_ into the world of client-side web application development as well. To that end, Taunus recommends that you give a shot to libraries that also do **one thing well**.

    In this brief article we'll recommend a couple different libraries that play well with Taunus, and you'll also learn how to search for modules that can give you access to other functionality you may be interested in.

    # Using `dominus` for DOM querying

    [Dominus][2] is an extra-small DOM querying library, currently clocking around **4kB minified and gzipped**, almost _ten times smaller_ than it's competition. Unlike jQuery and popular friends, Dominus doesn't provide AJAX features, layout math, `<form>` manipulation, promises, tens of event binding methods, a selector engine written in plain JavaScript, nor a myriad of utility functions. Instead, Dominus focuses solely on providing a rich DOM querying and manipulation API that gets rid of inconsistencies across browsers.

    While the API isn't exactly compatible with jQuery, it is definitely familiar to the jQuery adept. Chaining, versatility, expressiveness, and raw power are all core concerns for Dominus. You'll find that Dominus has more consistently named methods, given that it was built with a concise API in mind.

    There's a few differences in semantics, and I believe that's a good thing. For instance, if you do `.value` on a checkbox or radio button you'll get back whether the input is checked. Similarly, if you call `.text` on the input you'll get the text back, which is most often what you wanted to get.

    ```js
    var a = require('dominus');
    var b = jQuery;

    a('<input>').attr({ type: 'radio', value: 'Foo' }).text();
    // <- 'Foo'

    a('<input>').attr({ type: 'radio', checked: true }).value();
    // <- true

    b('<input>').attr({ type: 'radio', value: 'Foo' }).text();
    // <- ''

    b('<input>').attr({ type: 'radio', checked: true }).val();
    // <- 'Foo'
    ```

    One of the best aspects of Dominus, _besides its small size_, is the fact that it extends native JavaScript arrays _(using [`poser`][5])_. That means you have access to all of the `Array` functional methods on any `Dominus` collections, such as `.forEach`, `.map`, `.filter`, `.sort` and so on.

    Taunus doesn't make any extensive DOM manipulation _(nor querying)_ and doesn't need to use Dominus, but it may find a home in your application.

    You can check out the _complete API documentation_ for `dominus` on [its GitHub repository][2].

    # Using `xhr` to make AJAX requests

    A small program called [`xhr`][4] can be used to make AJAX requests and it's bundled with Taunus, because it needs it internally to communicate with the server. As such, it was trivial for Taunus to expose this engine and give you the ability to make AJAX calls of your own using it as well.

    You can check out [the API documentation][6] for an explanation of how our interface to `xhr` works, or you could also [see their API documentation][4] and use that directly instead.

    # Complementing your code with small modules

    There's an infinite number of modules that do just one thing well and are eager to be part of your applications. Leverage the Internet to find what you need. Small libraries tend to be better documented, concise to use, and simpler.

    Here's a few examples of modules you could consider.

    - [`vue`][15] gives you MVVM capabilities
    - [`observe-js`][7] to get data-binding
    - [`virtual-dom`][8] to use a virtual DOM diffing algorithm a la [Facebook React][9]
    - [`hint`][10] progressively enhances your HTML giving you more colorful tooltips
    - [`rome`][11] is a small calendar component

    You can look for relevant modules using [BrowserifySearch.org][13], the [`npm` search][14], asking around on Twitter, or just by Googling!

    [1]: /api
    [2]: https://github.com/bevacqua/dominus
    [4]: https://github.com/Raynos/xhr
    [5]: https://github.com/bevacqua/poser
    [6]: /api#-taunus-xhr-url-options-done-
    [7]: https://github.com/polymer/observe-js
    [8]: https://github.com/Matt-Esch/virtual-dom
    [9]: https://github.com/facebook/react
    [10]: https://github.com/bevacqua/hint
    [11]: https://github.com/bevacqua/rome
    [12]: https://github.com/bevacqua/hint
    [13]: http://browserifysearch.org/
    [14]: https://www.npmjs.org/
    [15]: https://github.com/yyx990803/vue
