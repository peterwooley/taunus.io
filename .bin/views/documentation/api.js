var jade = require("jadum/runtime");
module.exports = function api(locals) {
var jade_debug = [ new jade.DebugItem( 1, "views/documentation/api.jade" ) ];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;

jade_debug.unshift(new jade.DebugItem( 0, "views/documentation/api.jade" ));
jade_debug.unshift(new jade.DebugItem( 1, "views/documentation/api.jade" ));
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift(new jade.DebugItem( undefined, jade_debug[0].filename ));
jade_debug.unshift(new jade.DebugItem( 916, "views/documentation/api.jade" ));
buf.push("<h1>API Documentation</h1>\n<p>Here&#x27;s the API documentation for Taunus. If you&#x27;ve never used it before, we recommend going over the <a href=\"/getting-started\">Getting Started</a> guide before jumping into the API documentation. That way, you&#x27;ll get a better idea of what to look for and how to put together simple applications using Taunus, before going through documentation on every public interface to Taunus.</p>\n<p>Taunus exposes <em>three different public APIs</em>, and there&#x27;s also <strong>plugins to integrate Taunus and an HTTP server</strong>. This document covers all three APIs extensively. If you&#x27;re concerned about the inner workings of Taunus, please refer to the <a href=\"/getting-started\">Getting Started</a> guide. This document aims to only cover how the public interface affects application state, but <strong>doesn&#x27;t delve into implementation details</strong>.</p>\n<h1>Table of Contents</h1>\n<ul>\n<li>A <a href=\"#server-side-api\">server-side API</a> that deals with server-side rendering<ul>\n<li>The <a href=\"#-taunus-mount-addroute-options-\"><code class=\"hljs\">taunus.mount</code></a> method<ul>\n<li>Its <a href=\"#the-options-object\"><code class=\"hljs\">options</code></a> argument<ul>\n<li><a href=\"#-options-layout-\"><code class=\"hljs\">layout</code></a></li>\n<li><a href=\"#-options-routes-\"><code class=\"hljs\">routes</code></a></li>\n<li><a href=\"#-options-getdefaultviewmodel-\"><code class=\"hljs\">getDefaultViewModel</code></a></li>\n<li><a href=\"#-options-plaintext-\"><code class=\"hljs\">plaintext</code></a></li>\n<li><a href=\"#-options-resolvers-\"><code class=\"hljs\">resolvers</code></a></li>\n<li><a href=\"#-options-version-\"><code class=\"hljs\">version</code></a></li>\n<li><a href=\"#-options-deferminified-\"><code class=\"hljs\">deferMinified</code></a></li>\n</ul>\n</li>\n<li>Its <a href=\"#-addroute-definition-\"><code class=\"hljs\">addRoute</code></a> argument</li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-render-action-viewmodel-req-res-next-\"><code class=\"hljs\">taunus.render</code></a> method</li>\n<li>The <a href=\"#-taunus-resolve-action-data-\"><code class=\"hljs\">taunus.resolve</code></a> method</li>\n<li>The <a href=\"#-taunus-redirect-req-res-url-options-\"><code class=\"hljs\">taunus.redirect</code></a> method</li>\n<li>The <a href=\"#-taunus-rebuilddefaultviewmodel-done-\"><code class=\"hljs\">taunus.rebuildDefaultViewModel</code></a> method</li>\n</ul>\n</li>\n<li><a href=\"#server-side-controllers\">Server-side controllers</a></li>\n<li>A <a href=\"#http-framework-plugins\">suite of plugins</a> can integrate Taunus and an HTTP server<ul>\n<li>Using <a href=\"#using-taunus-express-\"><code class=\"hljs\">taunus-express</code></a> for <a href=\"http://expressjs.com\">Express</a></li>\n<li>Using <a href=\"#using-taunus-hapi-\"><code class=\"hljs\">taunus-hapi</code></a> for <a href=\"http://hapijs.com\">Hapi</a></li>\n</ul>\n</li>\n<li>A <a href=\"#command-line-interface\">CLI that produces a wiring module</a> for the client-side<ul>\n<li>The <a href=\"#-output-\"><code class=\"hljs\">--output</code></a> flag</li>\n<li>The <a href=\"#-watch-\"><code class=\"hljs\">--watch</code></a> flag</li>\n<li>The <a href=\"#-transform-module-\"><code class=\"hljs\">--transform &#x3C;module&#x3E;</code></a> flag</li>\n<li>The <a href=\"#-defer-actions-\"><code class=\"hljs\">--defer</code></a> flag</li>\n<li>The <a href=\"#-resolvers-module-\"><code class=\"hljs\">--resolvers &#x3C;module&#x3E;</code></a> flag</li>\n<li>The <a href=\"#-bundle-\"><code class=\"hljs\">--bundle</code></a> flag</li>\n</ul>\n</li>\n<li>A <a href=\"#client-side-api\">client-side API</a> that deals with client-side rendering<ul>\n<li>The <a href=\"#-taunus-mount-container-wiring-options-\"><code class=\"hljs\">taunus.mount</code></a> method<ul>\n<li>Using the <a href=\"#using-the-auto-strategy\"><code class=\"hljs\">auto</code></a> strategy</li>\n<li>Using the <a href=\"#using-the-inline-strategy\"><code class=\"hljs\">inline</code></a> strategy</li>\n<li>Using the <a href=\"#using-the-manual-strategy\"><code class=\"hljs\">manual</code></a> strategy</li>\n<li><a href=\"#caching\">Caching</a></li>\n<li><a href=\"#prefetching\">Prefetching</a></li>\n<li><a href=\"#versioning\">Versioning</a></li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-on-type-fn-\"><code class=\"hljs\">taunus.on</code></a> method</li>\n<li>The <a href=\"#-taunus-once-type-fn-\"><code class=\"hljs\">taunus.once</code></a> method</li>\n<li>The <a href=\"#-taunus-off-type-fn-\"><code class=\"hljs\">taunus.off</code></a> method</li>\n<li>The <a href=\"#-taunus-intercept-action-fn-\"><code class=\"hljs\">taunus.intercept</code></a> method</li>\n<li>The <a href=\"#-taunus-partial-container-action-model-\"><code class=\"hljs\">taunus.partial</code></a> method</li>\n<li>The <a href=\"#-taunus-navigate-url-options-\"><code class=\"hljs\">taunus.navigate</code></a> method</li>\n<li>The <a href=\"#-taunus-route-url-\"><code class=\"hljs\">taunus.route</code></a> method<ul>\n<li>The <a href=\"#-taunus-route-equals-route-route-\"><code class=\"hljs\">taunus.route.equals</code></a> method</li>\n</ul>\n</li>\n<li>The <a href=\"#-taunus-redirect-options-\"><code class=\"hljs\">taunus.redirect</code></a> method</li>\n<li>The <a href=\"#-taunus-resolve-on-the-client\"><code class=\"hljs\">taunus.resolve</code></a> method</li>\n<li>The <a href=\"#-taunus-state-\"><code class=\"hljs\">taunus.state</code></a> property</li>\n<li>The <a href=\"#-taunus-xhr-url-options-done-\"><code class=\"hljs\">taunus.xhr</code></a> method</li>\n<li>The <a href=\"#using-taunus-prefetch-url-element-\"><code class=\"hljs\">taunus.prefetch</code></a> method</li>\n<li><a href=\"#debugging-taunus\">Debugging Taunus</a></li>\n</ul>\n</li>\n<li><a href=\"#client-side-controllers\">Client-side controllers</a></li>\n<li>The <a href=\"#the-taunusrc-manifest\"><code class=\"hljs\">.taunusrc</code></a> manifest</li>\n</ul>\n<h1>Server-side API</h1>\n<p>The server-side API is used to set up the view router. It then gets out of the way, allowing the client-side to eventually take over and add any extra sugar on top, <em>including client-side rendering</em>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.mount(addRoute, options?)</code></h2>\n<p>Mounts Taunus on top of a server-side router, by registering each route in <code class=\"hljs\">options.routes</code> with the <code class=\"hljs\">addRoute</code> method.</p>\n<blockquote>\n<p>Note that most of the time, <strong>this method shouldn&#x27;t be invoked directly</strong>, but rather through one of the <a href=\"#http-framework-plugins\">HTTP framework plugins</a> presented below.</p>\n</blockquote>\n<p>Here&#x27;s an incomplete example of how this method may be used. It is incomplete because route definitions have more options beyond the <code class=\"hljs\">route</code> and <code class=\"hljs\">action</code> properties.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\ntaunus.mount(addRoute, {\n  routes: [{ route: <span class=\"hljs-string\">&#x27;/&#x27;</span>, action: <span class=\"hljs-string\">&#x27;home/index&#x27;</span> }]\n});\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addRoute</span> (<span class=\"hljs-params\">definition</span>) </span>{\n  app.get(definition.route, definition.action);\n}\n</code></pre>\n<p>Let&#x27;s go over the options you can pass to <code class=\"hljs\">taunus.mount</code> first.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>The <code class=\"hljs\">options?</code> object</h4>\n<p>There&#x27;s a few options that can be passed to the server-side mountpoint. You&#x27;re probably going to be passing these to your <a href=\"#http-framework-plugins\">HTTP framework plugin</a>, rather than using <code class=\"hljs\">taunus.mount</code> directly.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.layout?</code></h6>\n<p>The <code class=\"hljs\">layout</code> property is expected to have the <code class=\"hljs\">function(data)</code> signature. It&#x27;ll be invoked whenever a full HTML document needs to be rendered, and a <code class=\"hljs\">data</code> object will be passed to it. That object will contain everything you&#x27;ve set as the view model, plus a <code class=\"hljs\">partial</code> property containing the raw HTML of the rendered partial view. Your <code class=\"hljs\">layout</code> method will typically wrap the raw HTML for the partial with the bare bones of an HTML document. Check out <a href=\"https://github.com/ponyfoo/ponyfoo/blob/33271751312db6e92059d98293d0a7ac6e9e8e5b/views/server/layout/layout.jade\">the <code class=\"hljs\">layout.jade</code> used in Pony Foo</a> as an example.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.routes</code></h6>\n<p>The other big option is <code class=\"hljs\">routes</code>, which expects a collection of route definitions. Route definitions use a number of properties to determine how the route is going to behave.</p>\n<p>Here&#x27;s an example route that uses the <a href=\"http://expressjs.com\">Express</a> routing scheme.</p>\n<pre><code class=\"hljs javascript\">{\n  route: <span class=\"hljs-string\">&#x27;/articles/:slug&#x27;</span>,\n  action: <span class=\"hljs-string\">&#x27;articles/article&#x27;</span>,\n  ignore: <span class=\"hljs-literal\">false</span>,\n  cache: <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-title\">inherit</span>&#x3E;</span>\n}</span>\n</code></pre>\n<ul>\n<li><code class=\"hljs\">route</code> is a route in the format your HTTP framework of choice understands</li>\n<li><code class=\"hljs\">action</code> is the name of your controller action. It&#x27;ll be used to find the server-side controller, the default view that should be used with this route, and the client-side controller</li>\n<li><code class=\"hljs\">cache</code> can be used to determine the client-side caching behavior in this application path, and it&#x27;ll default to inheriting from the options passed to <code class=\"hljs\">taunus.mount</code> <em>on the client-side</em></li>\n<li><code class=\"hljs\">ignore</code> is used in those cases where you want a URL to be ignored by the client-side router even if there&#x27;s a catch-all route that would match that URL</li>\n</ul>\n<p>As an example of the <code class=\"hljs\">ignore</code> use case, consider the routing table shown below. The client-side router doesn&#x27;t know <em>(and can&#x27;t know unless you point it out)</em> what routes are server-side only, and it&#x27;s up to you to point those out.</p>\n<pre><code class=\"hljs javascript\">[\n  { route: <span class=\"hljs-string\">&#x27;/&#x27;</span>, action: <span class=\"hljs-string\">&#x27;/home/index&#x27;</span> },\n  { route: <span class=\"hljs-string\">&#x27;/feed&#x27;</span>, ignore: <span class=\"hljs-literal\">true</span> },\n  { route: <span class=\"hljs-string\">&#x27;/*&#x27;</span>, action: <span class=\"hljs-string\">&#x27;error/not-found&#x27;</span> }\n]\n</code></pre>\n<p>This step is necessary whenever you have an anchor link pointed at something like an RSS feed. The <code class=\"hljs\">ignore</code> property is effectively telling the client-side <em>&#x22;don&#x27;t hijack links containing this URL&#x22;</em>.</p>\n<p>Please note that external links are never hijacked. Only same-origin links containing a URL that matches one of the routes will be hijacked by Taunus. External links don&#x27;t need to be <code class=\"hljs\">ignore</code>d.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.getDefaultViewModel?</code></h6>\n<p>The <code class=\"hljs\">getDefaultViewModel(done)</code> property can be a method that puts together the base view model, which will then be extended on an action-by-action basis. When you&#x27;re done creating a view model, you can invoke <code class=\"hljs\">done(null, model)</code>. If an error occurs while building the view model, you should call <code class=\"hljs\">done(err)</code> instead.</p>\n<p>Taunus will throw an error if <code class=\"hljs\">done</code> is invoked with an error, so you might want to put safeguards in place as to avoid that from happenning. The reason this method is asynchronous is because you may need database access or somesuch when putting together the defaults. The reason this is a method and not just an object is that the defaults may change due to human interaction with the application, and in those cases <a href=\"#taunus-rebuilddefaultviewmodel\">the defaults can be rebuilt</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.plaintext?</code></h6>\n<p>The <code class=\"hljs\">plaintext</code> options object is passed directly to <a href=\"https://github.com/bevacqua/hget\">hget</a>, and it&#x27;s used to <a href=\"https://github.com/ponyfoo/ponyfoo/blob/f6d6b5068ff03a387f503900160d9fdc1e749750/controllers/routing.js#L70-L72\">tweak the plaintext version</a> of your site.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.resolvers?</code></h6>\n<p>Resolvers are used to determine the location of some of the different pieces of your application. Typically you won&#x27;t have to touch these in the slightest.</p>\n<table>\n<thead>\n<tr>\n<th>Signature</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">getServerController(action)</code></td>\n<td>Return path to server-side controller action handler module</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">getView(action)</code></td>\n<td>Return path to view template module</td>\n</tr>\n</tbody>\n</table>\n<p>The <code class=\"hljs\">addRoute</code> method passed to <code class=\"hljs\">taunus.mount</code> on the server-side is mostly going to be used internally by the HTTP framework plugins, so feel free to skip over the following section.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.version?</code></h6>\n<p>Refer to the <a href=\"#versioning\">Versioning</a> section.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.getPartial?</code></h6>\n<p>By default, Taunus will render partials on the server-side by looking up the module for an action method, and calling that action passing in a model.</p>\n<p>You can override the default behavior by setting <code class=\"hljs\">options.getPartial</code> to a function. This method takes three parameters.</p>\n<ul>\n<li><code class=\"hljs\">action</code> is the action that needs to be rendered</li>\n<li><code class=\"hljs\">model</code> is the model you can use to render the view for that action</li>\n<li><code class=\"hljs\">done(err, html)</code> is called when you&#x27;re done, passing in the resulting <code class=\"hljs\">html</code> for the partial</li>\n</ul>\n<p>Note that if you don&#x27;t set <code class=\"hljs\">getPartial</code>, Taunus will just require your controller action method and invoke that instead.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h6><code class=\"hljs\">options.deferMinified?</code></h6>\n<p>When views and controllers are lazily loaded, they are compiled and bundled using Browserify. Taunus will even produce a source map. To avoid the source map, and minify the bundle instead, set <code class=\"hljs\">deferMinified</code> to <code class=\"hljs\">true</code>.</p>\n<p>You&#x27;ll probably want to set <code class=\"hljs\">deferMinified</code> to whether the application is running on the production environment.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4><code class=\"hljs\">addRoute(definition)</code></h4>\n<p>The <code class=\"hljs\">addRoute(definition)</code> method will be passed a route definition, containing the following properties. This method is expected to register a route in your HTTP framework&#x27;s router.</p>\n<ul>\n<li><code class=\"hljs\">route</code> is the route that you set as <code class=\"hljs\">definition.route</code></li>\n<li><code class=\"hljs\">action</code> is the action as passed to the route definition</li>\n<li><code class=\"hljs\">actionFn</code> will be the controller for this action method</li>\n<li><code class=\"hljs\">middleware</code> will be an array of methods to be executed before <code class=\"hljs\">actionFn</code></li>\n</ul>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.render(action, viewModel, req, res, next)</code></h2>\n<p>This method is almost an implementation detail as you should be using Taunus through one of the plugins anyways, so we won&#x27;t go very deep into it.</p>\n<p>The render method is what Taunus uses to render views by constructing HTML, JSON, or plaintext responses. The <code class=\"hljs\">action</code> property determines the default view that will be rendered. The <code class=\"hljs\">viewModel</code> will be extended by <a href=\"#-options-getdefaultviewmodel-\">the default view model</a>, and it may also override the default <code class=\"hljs\">action</code> by setting <code class=\"hljs\">viewModel.model.action</code>.</p>\n<p>The <code class=\"hljs\">req</code>, <code class=\"hljs\">res</code>, and <code class=\"hljs\">next</code> arguments are expected to be the Express routing arguments, but they can also be mocked <em>(which is in fact what the Hapi plugin does)</em>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.rebuildDefaultViewModel(done?)</code></h2>\n<p>Once Taunus has been mounted, calling this method will rebuild the view model defaults using the <code class=\"hljs\">getDefaultViewModel</code> that was passed to <code class=\"hljs\">taunus.mount</code> in the options. An optional <code class=\"hljs\">done</code> callback will be invoked when the model is rebuilt.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.resolve(action, data?)</code></h2>\n<p>Returns the first route that matches an <code class=\"hljs\">action</code>, replacing named parameters with data from the <code class=\"hljs\">data</code> object. If a matching route is not found, <code class=\"hljs\">null</code> is returned.</p>\n<blockquote>\n<p>If a route is matched but a required named parameter isn&#x27;t in <code class=\"hljs\">data</code>, <strong>an exception will be thrown</strong>.</p>\n</blockquote>\n<p>This method is most useful when composing the URL for a redirect or an action link within a template, as a means to keep the route declaration isolated from the route itself. If the route changes, the method will reflect the newer route as long as the parameters stay the same, resulting in increased maintainability. <em>The method is available in both layout templates and partial view templates.</em></p>\n<h6>Example</h6>\n<pre><code class=\"hljs javascript\">taunus.resolve(<span class=\"hljs-string\">&#x27;projects/project&#x27;</span>, {\n  name: <span class=\"hljs-string\">&#x27;puppies&#x27;</span>, organization: <span class=\"hljs-string\">&#x27;caniuse&#x27;</span>\n});\n<span class=\"hljs-comment\">// &#x3C;- /p/caniuse/puppies</span>\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.redirect(req, res, url, options?)</code></h2>\n<p>Redirects the response to a different URL. If the request accepts HTML, this method is equivalent to <code class=\"hljs\">res.redirect(url)</code>. If the request accepts JSON, a specially crafted JSON response will trigger a client-side redirect using <a href=\"#-taunus-navigate-url-options-\">taunus.navigate</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">hard</code></td>\n<td>Uses a full page redirect when <code class=\"hljs\">true</code></td>\n</tr>\n<tr>\n<td><code class=\"hljs\">force</code></td>\n<td>Client-side redirects will be carried out even if the target URL is the same as the current <code class=\"hljs\">location</code></td>\n</tr>\n</tbody>\n</table>\n<h6>Example</h6>\n<pre><code class=\"hljs javascript\">taunus.redirect(req, res, <span class=\"hljs-string\">&#x27;/login&#x27;</span>);\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>Server-Side Controllers</h1>\n<p>On the server-side, controllers are modules that export a single function. The parameters passed to these controllers depend on the server-side HTTP framework that&#x27;s being used.</p>\n<p>For example, Express gives us three parameters: <code class=\"hljs\">req</code>, <code class=\"hljs\">res</code> and <code class=\"hljs\">next</code>. Hapi gives us two instead: <code class=\"hljs\">request</code> and <code class=\"hljs\">reply</code>.</p>\n<p>Here&#x27;s a sample controller using <code class=\"hljs\">taunus-express</code>, as <a href=\"#using-taunus-express-\">detailed below</a>. This is a very simple controller where we are setting the special <code class=\"hljs\">viewModel</code> property on the response, and calling <code class=\"hljs\">next</code>. Suppose this controller is the <code class=\"hljs\">product/home</code> action handler.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res, next</span>) </span>{\n  res.viewModel = {\n    model: {\n      title: <span class=\"hljs-string\">&#x27;view title&#x27;</span>\n    }\n  };\n  next();\n};\n</code></pre>\n<p>As you can see, Taunus won&#x27;t alter the API provided by Express. Instead, it builds upon the notion of using middleware. Once the <code class=\"hljs\">product/home</code> view is rendered and JavaScript loads, the <code class=\"hljs\">product/home</code> view controller is executed on the client-side.</p>\n<p>You could change the view to be rendered by setting the <code class=\"hljs\">action</code> property on the <code class=\"hljs\">model</code>. In the example shown below this would mean that the <code class=\"hljs\">error/offline</code> view would be rendered. The client-side controller will be that of <code class=\"hljs\">error/offline</code>, as well. View controllers are tied to the view that gets rendered.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res, next</span>) </span>{\n  res.viewModel = {\n    model: {\n      title: <span class=\"hljs-string\">&#x27;view title&#x27;</span>\n    }\n  };\n  <span class=\"hljs-keyword\">if</span> (offline) {\n    res.viewModel.model.action = <span class=\"hljs-string\">&#x27;error/offline&#x27;</span>;\n  }\n  next();\n};\n</code></pre>\n<p>Having a default action and the ability to redirect to another gives us a lot of flexibility when determining how to respond to a request.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>HTTP Framework Plugins</h1>\n<p>There&#x27;s currently two different HTTP frameworks <em>(<a href=\"http://expressjs.com\">Express</a> and <a href=\"http://hapijs.com\">Hapi</a>)</em> that you can readily use with Taunus without having to deal with any of the route plumbing yourself.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2>Using <code class=\"hljs\">taunus-express</code></h2>\n<p>The <code class=\"hljs\">taunus-express</code> plugin is probably the easiest to use, as Taunus was originally developed with just <a href=\"http://expressjs.com\">Express</a> in mind. In addition to the options already outlined for <a href=\"#-taunus-mount-addroute-options-\">taunus.mount</a>, you can add middleware for any route individually.</p>\n<ul>\n<li><code class=\"hljs\">middleware</code> are any methods you want Taunus to execute as middleware in Express applications</li>\n</ul>\n<p>To get <code class=\"hljs\">taunus-express</code> going you can use the following piece of code, provided that you come up with an <code class=\"hljs\">options</code> object.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\n<span class=\"hljs-keyword\">var</span> taunus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> taunusExpress = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus-express&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;express&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> app = express();\n<span class=\"hljs-keyword\">var</span> options = {\n  <span class=\"hljs-comment\">// ...</span>\n};\n\ntaunusExpress(taunus, app, options);\n</code></pre>\n<p>The <code class=\"hljs\">taunusExpress</code> method will merely set up Taunus and add the relevant routes to your Express application by calling <code class=\"hljs\">app.get</code> a bunch of times. You can <a href=\"https://github.com/taunus/taunus-express\">find taunus-express on GitHub</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2>Using <code class=\"hljs\">taunus-hapi</code></h2>\n<p>The <code class=\"hljs\">taunus-hapi</code> plugin is a bit more involved, and you&#x27;ll have to create a Pack in order to use it. In addition to <a href=\"#-taunus-mount-addroute-options-\">the options we&#x27;ve already covered</a>, you can add <code class=\"hljs\">config</code> on any route.</p>\n<ul>\n<li><code class=\"hljs\">config</code> is passed directly into the route registered with Hapi, giving you the most flexibility</li>\n</ul>\n<p>To get <code class=\"hljs\">taunus-hapi</code> going you can use the following piece of code, and you can bring your own <code class=\"hljs\">options</code> object.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\n<span class=\"hljs-keyword\">var</span> Hapi = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;hapi&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> taunus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> taunusHapi = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus-hapi&#x27;</span>)(taunus);\n<span class=\"hljs-keyword\">var</span> pack = <span class=\"hljs-keyword\">new</span> Hapi.Pack();\n\npack.register({\n  plugin: taunusHapi,\n  options: {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n</code></pre>\n<p>The <code class=\"hljs\">taunusHapi</code> plugin will mount Taunus and register all of the necessary routes. You can <a href=\"https://github.com/taunus/taunus-hapi\">find taunus-hapi on GitHub</a>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>Command-Line Interface</h1>\n<p>Once you&#x27;ve set up the server-side to render your views using Taunus, it&#x27;s only logical that you&#x27;ll want to render the views in the client-side as well, effectively converting your application into a single-page application after the first view has been rendered on the server-side.</p>\n<p>The Taunus CLI is an useful intermediary in the process of getting the configuration you wrote so far for the server-side to also work well in the client-side.</p>\n<p>Install it globally for development, but remember to use local copies for production-grade uses.</p>\n<pre><code class=\"hljs shell\">npm install -g taunus\n</code></pre>\n<p>When invoked without any arguments, the CLI will simply follow the default conventions to find your route definitions, views, and client-side controllers.</p>\n<pre><code class=\"hljs shell\">taunus\n</code></pre>\n<p>By default, the output will be printed to the standard output, making for a fast debugging experience. Here&#x27;s the output if you just had a single <code class=\"hljs\">home/index</code> route, and the matching view and client-side controller existed.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\n<span class=\"hljs-keyword\">var</span> templates = {\n  <span class=\"hljs-string\">&#x27;home/index&#x27;</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./views/home/index.js&#x27;</span>)\n};\n\n<span class=\"hljs-keyword\">var</span> controllers = {\n  <span class=\"hljs-string\">&#x27;home/index&#x27;</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;../client/js/controllers/home/index.js&#x27;</span>)\n};\n\n<span class=\"hljs-keyword\">var</span> routes = [\n  {\n    route: <span class=\"hljs-string\">&#x27;/&#x27;</span>,\n    action: <span class=\"hljs-string\">&#x27;home/index&#x27;</span>\n  }\n];\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  templates: templates,\n  controllers: controllers,\n  routes: routes\n};\n</code></pre>\n<p>You can use a few options to alter the outcome of invoking <code class=\"hljs\">taunus</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--output</code></h2>\n<p><sub>the <code class=\"hljs\">-o</code> alias is available</sub></p>\n<p>Output is written to a file instead of to standard output. The file path used will be the <code class=\"hljs\">client_wiring</code> option in <a href=\"#the-taunusrc-manifest\"><code class=\"hljs\">.taunusrc</code></a>, which defaults to <code class=\"hljs\">&#x27;.bin/wiring.js&#x27;</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--watch</code></h2>\n<p><sub>the <code class=\"hljs\">-w</code> alias is available</sub></p>\n<p>Whenever a server-side route definition changes, the output is printed again to either standard output or a file, depending on whether <code class=\"hljs\">--output</code> was used.</p>\n<p>The program won&#x27;t exit.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--transform &#x3C;module&#x3E;</code></h2>\n<p><sub>the <code class=\"hljs\">-t</code> alias is available</sub></p>\n<p>This flag allows you to transform server-side routes into something the client-side understands. Express routes are completely compatible with the client-side router, but Hapi routes need to be transformed using the <a href=\"https://github.com/taunus/hapiify\"><code class=\"hljs\">hapiify</code></a> module.</p>\n<pre><code class=\"hljs shell\">npm install hapiify\ntaunus -t hapiify\n</code></pre>\n<p>Using this transform relieves you from having to define the same routes twice using slightly different formats that convey the same meaning.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--defer [actions]</code></h2>\n<p><sub>the <code class=\"hljs\">-d</code> alias is available</sub></p>\n<p>Here is where things get interesting. The <code class=\"hljs\">--defer</code> flag allows you to defer loading for zero or more actions. Excluding the controller and view templates for any deferred action can significantly reduce the fingerprint of your application.</p>\n<p>The <code class=\"hljs\">[actions]</code> argument determines what actions get deferred, and which don&#x27;t. It expects a comma-separated list of actions, where you can pass in either the controller name, or both the controller name and the action name. Using <code class=\"hljs\">?</code> acts as a wildcard.</p>\n<p>For example, using <code class=\"hljs\">admin</code> <em>(equivalent to using <code class=\"hljs\">admin/?</code>)</em> will defer every action under the <code class=\"hljs\">admin</code> controller. Using <code class=\"hljs\">admin/nuke</code> will only defer the <code class=\"hljs\">admin/nuke</code> action. If you omit the <code class=\"hljs\">[actions]</code> parameter entirely, the default value of <code class=\"hljs\">&#x27;?&#x27;</code> will be used and everything will be deferred.</p>\n<p>When components get deferred, they&#x27;ll be loaded as soon as Taunus detects that they&#x27;re needed. This can happen in a few places.</p>\n<ul>\n<li>The user navigates to (or <a href=\"#prefetching\"><em>prefetches</em></a>) the <code class=\"hljs\">/admin</code> route, and <code class=\"hljs\">admin/index</code> was deferred, and its components aren&#x27;t cached on the client-side yet</li>\n<li>A controller uses <code class=\"hljs\">taunus.partial</code> to render an action that was deferred, and its components aren&#x27;t cached on the client-side yet</li>\n<li>The user navigates to the <code class=\"hljs\">/admin</code> route, and its matching <code class=\"hljs\">admin/index</code> route wasn&#x27;t deferred, but the server-side controller decides to change the action to <code class=\"hljs\">admin/superadmin</code>. When the response gets to the client, it&#x27;ll need to ask the server for the <code class=\"hljs\">admin/superadmin</code> template if the client doesn&#x27;t already have it</li>\n</ul>\n<p>You don&#x27;t have to worry about those different scenarios, though, as Taunus handles them all for you transparently. You should <a href=\"/performance#send-views-and-controllers-to-the-client-selectively\">learn more about deferred loading on the Performance Optimization guide</a>.</p>\n<blockquote>\n<p>A possible concern with deferred execution is that partial views may not be rendered immediately, as a request may be necessary to fetch the controller or template for the partial.</p>\n</blockquote>\n<p>Some other considerations, regarding how deferred components get bundled, are listed in the <a href=\"/performance#send-views-and-controllers-to-the-client-selectively\">Performance Optimization</a> guide.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--resolvers &#x3C;module&#x3E;</code></h2>\n<p><sub>the <code class=\"hljs\">-r</code> alias is available</sub></p>\n<p>Similarly to the <a href=\"#-options-resolvers-\"><code class=\"hljs\">resolvers</code></a> option that you can pass to <a href=\"#-taunus-mount-addroute-options-\"><code class=\"hljs\">taunus.mount</code></a>, these resolvers can change the way in which file paths are resolved.</p>\n<table>\n<thead>\n<tr>\n<th>Signature</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">getClientController(action)</code></td>\n<td>Return path to client-side controller action handler module</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">getView(action)</code></td>\n<td>Return path to view template module</td>\n</tr>\n</tbody>\n</table>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">--bundle</code></h2>\n<p><sub>the <code class=\"hljs\">-b</code> alias is available</sub></p>\n<p>Under this experimental flag, the CLI will use Browserify to compile a standalone module that includes the wiring normally exported by the CLI plus all of Taunus <a href=\"https://github.com/umdjs/umd\">as a UMD module</a>.</p>\n<p>This allows you to use Taunus on the client-side even if you don&#x27;t want to use <a href=\"http://browserify.org\">Browserify</a> directly.</p>\n<p>Feedback and suggestions about this flag, <em>and possible alternatives that would make Taunus easier to use</em>, are welcome.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>Client-side API</h1>\n<p>Just like the server-side, everything in the client-side begins at the mountpoint. Once the application is mounted, anchor links will be hijacked and the client-side router will take over view rendering. Client-side controllers are executed whenever a view is rendered.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.mount(container, wiring, options?)</code></h2>\n<p>The mountpoint takes a root container, the wiring module, and an options parameter. The <code class=\"hljs\">container</code> is where client-side-rendered views will be placed, by replacing whatever HTML contents already exist. You can pass in the <code class=\"hljs\">wiring</code> module exactly as built by the CLI, and no further configuration is necessary.</p>\n<p>When the mountpoint executes, Taunus will configure its internal state, <em>set up the client-side router</em>, run the client-side controller for the server-side rendered view, and start hijacking links.</p>\n<p>As an example, consider a browser makes a <code class=\"hljs\">GET</code> request for <code class=\"hljs\">/articles/the-fox</code> for the first time. Once <code class=\"hljs\">taunus.mount(container, wiring)</code> is invoked on the client-side, several things would happen in the order listed below.</p>\n<ul>\n<li>Taunus sets up the client-side view routing engine</li>\n<li>If enabled <em>(via <code class=\"hljs\">options</code>)</em>, the caching engine is configured</li>\n<li>Taunus obtains the view model <em>(more on this later)</em></li>\n<li>When a view model is obtained, the <code class=\"hljs\">&#x27;start&#x27;</code> event is emitted</li>\n<li>Anchor links start being monitored for clicks <em>(at this point your application becomes a <a href=\"http://en.wikipedia.org/wiki/Single-page_application\">SPA</a>)</em></li>\n<li>The <code class=\"hljs\">articles/article</code> client-side controller is executed</li>\n</ul>\n<p>That&#x27;s quite a bit of functionality, but if you think about it, most other frameworks also render the view at this point, <em>rather than on the server-side!</em></p>\n<p>In order to better understand the process, I&#x27;ll walk you through the <code class=\"hljs\">options</code> parameter.</p>\n<p>First off, the <code class=\"hljs\">bootstrap</code> option determines the strategy used to pull the view model of the server-side rendered view into the client-side. There are three possible strategies available: <code class=\"hljs\">auto</code> <em>(the default strategy)</em>, <code class=\"hljs\">inline</code>, or <code class=\"hljs\">manual</code>. The <code class=\"hljs\">auto</code> strategy involves the least work, which is why it&#x27;s the default.</p>\n<ul>\n<li><code class=\"hljs\">auto</code> will make an AJAX request for the view model</li>\n<li><code class=\"hljs\">inline</code> expects you to place the model into a <code class=\"hljs\">&#x3C;script type=&#x27;text/taunus&#x27;&#x3E;</code> tag</li>\n<li><code class=\"hljs\">manual</code> expects you to get the view model however you want to, and then let Taunus know when it&#x27;s ready</li>\n</ul>\n<p>Let&#x27;s go into detail about each of these strategies.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>Using the <code class=\"hljs\">auto</code> strategy</h4>\n<p>The <code class=\"hljs\">auto</code> strategy means that Taunus will make use of an AJAX request to obtain the view model. <em>You don&#x27;t have to do anything else</em> and this is the default strategy. This is the <strong>most convenient strategy, but also the slowest</strong> one.</p>\n<p>It&#x27;s slow because the view model won&#x27;t be requested until the bulk of your JavaScript code has been downloaded, parsed, executed, and <code class=\"hljs\">taunus.mount</code> is invoked.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>Using the <code class=\"hljs\">inline</code> strategy</h4>\n<p>The <code class=\"hljs\">inline</code> strategy expects you to add a <code class=\"hljs\">data-taunus</code> attribute on the <code class=\"hljs\">container</code> element. This attribute must be equal to the <code class=\"hljs\">id</code> attribute of a <code class=\"hljs\">&#x3C;script&#x3E;</code> tag containing the serialized view model alongside the version information automatically injected by Taunus into the layout template data.</p>\n<pre><code class=\"hljs css\">div(data-taunus=&#x27;model&#x27;)!=partial\nscript#model(type=&#x27;text/taunus&#x27;)=JSON.stringify({ version: version, model: model })\n</code></pre>\n<p>Pay special attention to the fact that the model is not only made into a JSON string, <em>but also HTML encoded by Jade</em>. When Taunus extracts the model from the <code class=\"hljs\">&#x3C;script&#x3E;</code> tag it&#x27;ll unescape it, and then parse it as JSON.</p>\n<p>This strategy is also fairly convenient to set up, but it involves a little more work. It might be worthwhile to use in cases where models are small, but it will slow down server-side view rendering, as the model is inlined alongside the HTML.</p>\n<p>That means that the content you are supposed to be prioritizing is going to take longer to get to your humans, but once they get the HTML, this strategy will execute the client-side controller almost immediately.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>Using the <code class=\"hljs\">manual</code> strategy</h4>\n<p>The <code class=\"hljs\">manual</code> strategy is the most involved of the three, but also the most performant. In this strategy you&#x27;re supposed to add the following <em>(seemingly pointless)</em> snippet of code in a <code class=\"hljs\">&#x3C;script&#x3E;</code> other than the one that&#x27;s pulling down Taunus, so that they are pulled concurrently rather than serially.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\n<span class=\"hljs-built_in\">window</span>.taunusReady = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">model</span>) </span>{\n  <span class=\"hljs-built_in\">window</span>.taunusReady = model;\n};\n</code></pre>\n<p>Once you somehow get your hands on the view model, you should invoke <code class=\"hljs\">taunusReady(model)</code>. Considering you&#x27;ll be pulling both the view model and Taunus at the same time, a number of different scenarios may play out.</p>\n<ul>\n<li>The view model is loaded first, you call <code class=\"hljs\">taunusReady(model)</code> and wait for Taunus to take the model object and boot the application as soon as <code class=\"hljs\">taunus.mount</code> is executed</li>\n<li>Taunus loads first and <code class=\"hljs\">taunus.mount</code> is called first. In this case, Taunus will replace <code class=\"hljs\">window.taunusReady</code> with a special <code class=\"hljs\">boot</code> method. When the view model finishes loading, you call <code class=\"hljs\">taunusReady(model)</code> and the application finishes booting</li>\n</ul>\n<blockquote>\n<p>If this sounds a little mind-bending it&#x27;s because it is. It&#x27;s not designed to be pretty, but merely to be performant.</p>\n</blockquote>\n<p>Now that we&#x27;ve addressed the awkward bits, let&#x27;s cover the <em>&#x22;somehow get your hands on the view model&#x22;</em> aspect. My preferred method is using JSONP, as it&#x27;s able to deliver the smallest snippet possible, and it can take advantage of server-side caching. Considering you&#x27;ll probably want this to be an inline script, keeping it small is important.</p>\n<p>The good news is that the server-side supports JSONP out the box. Here&#x27;s a snippet of code you could use to pull down the view model and boot Taunus up as soon as both operations are ready.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-pi\">&#x27;use strict&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">inject</span> (<span class=\"hljs-params\">url</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;script&#x27;</span>);\n  script.src = url;\n  <span class=\"hljs-built_in\">document</span>.body.appendChild(script);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">injector</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> search = location.search;\n  <span class=\"hljs-keyword\">var</span> searchQuery = search ? <span class=\"hljs-string\">&#x27;&#x26;&#x27;</span> + search.substr(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">var</span> searchJson = <span class=\"hljs-string\">&#x27;?json&#x26;callback=taunusReady&#x27;</span> + searchQuery;\n  inject(location.pathname + searchJson);\n}\n\n<span class=\"hljs-built_in\">window</span>.taunusReady = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">model</span>) </span>{\n  <span class=\"hljs-built_in\">window</span>.taunusReady = model;\n};\n\ninjector();\n</code></pre>\n<p>As mentioned earlier, this approach involves getting your hands dirtier but it pays off by being the fastest of the three.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>Caching</h4>\n<p>The client-side in Taunus supports caching in-memory and using the embedded IndexedDB system by merely turning on the <code class=\"hljs\">cache</code> flag in the options passed to <code class=\"hljs\">taunus.mount</code> on the client-side.</p>\n<p>If you set <code class=\"hljs\">cache</code> to <code class=\"hljs\">true</code> then cached items will be considered <em>&#x22;fresh&#x22; (valid copies of the original)</em> for <strong>15 seconds</strong>. You can also set <code class=\"hljs\">cache</code> to a number, and that number of seconds will be used as the default instead.</p>\n<p>Caching can also be tweaked on individual routes. For instance, you could set <code class=\"hljs\">{ cache: true }</code> when mounting Taunus and then have <code class=\"hljs\">{ cache: 3600 }</code> on a route that you want to cache for a longer period of time.</p>\n<p>The caching layer is <em>seamlessly integrated</em> into Taunus, meaning that any views rendered by Taunus will be cached according to these caching rules. Keep in mind, however, that persistence at the client-side caching layer will only be possible in <a href=\"http://caniuse.com/#feat=indexeddb\">browsers that support IndexedDB</a>. In the case of browsers that don&#x27;t support IndexedDB, Taunus will use an in-memory cache, which will be wiped out whenever the human decides to close the tab in their browser.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4>Prefetching</h4>\n<p>If caching is enabled, the next logical step is prefetching. This is enabled just by adding <code class=\"hljs\">prefetch: true</code> to the options passed to <code class=\"hljs\">taunus.mount</code>. The prefetching feature will fire for any anchor link that&#x27;s trips over a <code class=\"hljs\">mouseover</code> or a <code class=\"hljs\">touchstart</code> event. If a route matches the URL in the <code class=\"hljs\">href</code>, an AJAX request will prefetch the view and cache its contents, improving perceived performance.</p>\n<p>When links are clicked before prefetching finishes, they&#x27;ll wait on the prefetcher to finish before immediately switching to the view, effectively cutting down the response time. If the link was already prefetched or otherwise cached, the view will be loaded immediately. If the human hovers over a link and another one was already being prefetched, then that one is aborted. This prevents prefetching from draining the bandwidth on clients with limited or intermittent connectivity.</p>\n<h4>Versioning</h4>\n<p>When enabled, versioning will look out for discrepancies between what&#x27;s currently on the client and what&#x27;s on the server, and reload everything necessary to make what&#x27;s on the client match what&#x27;s on the server.</p>\n<p>In order to turn it on, set the <code class=\"hljs\">version</code> field in the options when invoking <code class=\"hljs\">taunus.mount</code> <strong>on both the server-side and the client-side, using the same value</strong>. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.</p>\n<blockquote>\n<p>To make sure you don&#x27;t forget to change the version string in one of the mountpoints, please create a JSON file with just the version string and <code class=\"hljs\">require</code> that file in both sides.</p>\n<pre><code class=\"hljs shell\">echo &#x27;&#x22;1.0.0&#x22;&#x27; &#x3E; version.json\n</code></pre>\n</blockquote>\n<p>The default version string is set to <code class=\"hljs\">1</code>. The Taunus version will be prepended to yours, resulting in a value such as <code class=\"hljs\">t3.0.0;v1</code> where Taunus is running version <code class=\"hljs\">3.0.0</code> and your application is running version <code class=\"hljs\">1</code>.</p>\n<p>Refer to the Getting Started guide for a more detailed <a href=\"/getting-started#versioning\">analysis of the uses for versioning</a>. There&#x27;s some more nuggets of information in the <a href=\"/performance#use-versioning-to-ensure-cache-validity\">Performance Optimization</a> guide as well.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.on(type, fn)</code></h2>\n<p>Taunus emits a series of events during its lifecycle, and <code class=\"hljs\">taunus.on</code> is the way you can tune in and listen for these events using a subscription function <code class=\"hljs\">fn</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Arguments</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">&#x27;start&#x27;</code></td>\n<td><code class=\"hljs\">container, model, route</code></td>\n<td>Emitted when <code class=\"hljs\">taunus.mount</code> finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling <code class=\"hljs\">taunus.mount</code>.</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;render&#x27;</code></td>\n<td><code class=\"hljs\">container, model, route</code></td>\n<td>A view has just been rendered and its client-side controller is about to be invoked</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;change&#x27;</code></td>\n<td><code class=\"hljs\">route, model</code></td>\n<td>Same as <code class=\"hljs\">&#x27;render&#x27;</code>, but only if <code class=\"hljs\">container</code> is the mountpoint and the route has changed.</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;fetch.start&#x27;</code></td>\n<td><code class=\"hljs\">route, context</code></td>\n<td>Emitted whenever an XHR request starts.</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;fetch.done&#x27;</code></td>\n<td><code class=\"hljs\">route, context, data</code></td>\n<td>Emitted whenever an XHR request ends successfully.</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;fetch.abort&#x27;</code></td>\n<td><code class=\"hljs\">route, context</code></td>\n<td>Emitted whenever an XHR request is purposely aborted.</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">&#x27;fetch.error&#x27;</code></td>\n<td><code class=\"hljs\">route, context, err</code></td>\n<td>Emitted whenever an XHR request results in an HTTP error.</td>\n</tr>\n</tbody>\n</table>\n<p>Consider for instance that you&#x27;d like to keep track of every view that gets rendered, and what DOM element it gets placed into. The piece of code below would quickly do that for us.</p>\n<pre><code class=\"hljs javascript\">taunus.on(<span class=\"hljs-string\">&#x27;render&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">container</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Rendered a view on&#x27;</span>, container);\n});\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.once(type, fn)</code></h2>\n<p>This method is equivalent to <a href=\"#-taunus-on-type-fn-\"><code class=\"hljs\">taunus.on</code></a>, except the event listeners will be used once and then it&#x27;ll be discarded.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.off(type, fn)</code></h2>\n<p>Using this method you can remove any event listeners that were previously added using <code class=\"hljs\">.on</code> or <code class=\"hljs\">.once</code>. You must provide the type of event you want to remove and a reference to the event listener function that was originally used when calling <code class=\"hljs\">.on</code> or <code class=\"hljs\">.once</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.intercept(action?, fn)</code></h2>\n<p>This method can be used to anticipate model requests, before they ever make it into XHR requests. You can add interceptors for specific actions, which would be triggered only if the request matches the specified <code class=\"hljs\">action</code>. You can also add global interceptors by omitting the <code class=\"hljs\">action</code> parameter, or setting it to <code class=\"hljs\">*</code>.</p>\n<p>An interceptor function will receive an <code class=\"hljs\">event</code> parameter, containing a few different properties.</p>\n<ul>\n<li><code class=\"hljs\">url</code> contains the URL that needs a view model</li>\n<li><code class=\"hljs\">route</code> contains the full route object as you&#x27;d get from <a href=\"#-taunus-route-url-\"><code class=\"hljs\">taunus.route(url)</code></a></li>\n<li><code class=\"hljs\">parts</code> is just a shortcut for <code class=\"hljs\">route.parts</code></li>\n<li><code class=\"hljs\">preventDefault(data)</code> allows you to suppress the need for an AJAX request, commanding Taunus to use the response data you&#x27;ve provided instead</li>\n<li><code class=\"hljs\">defaultPrevented</code> tells you if some other handler has prevented the default behavior</li>\n<li><code class=\"hljs\">canPreventDefault</code> tells you if invoking <code class=\"hljs\">event.preventDefault</code> will have any effect</li>\n<li><code class=\"hljs\">data</code> starts as <code class=\"hljs\">null</code>, and it can later become the data passed to <code class=\"hljs\">preventDefault</code></li>\n</ul>\n<p>Interceptors are asynchronous, but if an interceptor spends longer than 50ms it&#x27;ll be short-circuited and calling <code class=\"hljs\">event.preventDefault</code> past that point won&#x27;t have any effect.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.partial(container, action, model)</code></h2>\n<p>This method provides you with access to the view-rendering engine of Taunus. You can use it to render the <code class=\"hljs\">action</code> view into the <code class=\"hljs\">container</code> DOM element, using the specified <code class=\"hljs\">model</code>. Once the view is rendered, the <code class=\"hljs\">render</code> event will be fired <em>(with <code class=\"hljs\">container, model</code> as arguments)</em> and the client-side controller for that view will be executed.</p>\n<p>Note that the partial may be rendered asynchronously if the <code class=\"hljs\">action</code> is <a href=\"#-defer-actions-\">deferred</a> and its components (view template, controller) aren&#x27;t readily available in the client yet. This method returns an event emitter, which you can use to guarantee that you continue exection after the partial has been rendered.</p>\n<h4>Example</h4>\n<p>Given a deferred <code class=\"hljs\">&#x27;tags&#x27;</code> partial view like this function:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">model</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> model.length ? <span class=\"hljs-string\">&#x27;&#x3C;ul&#x3E;&#x3C;li&#x3E;&#x27;</span> + model.join(<span class=\"hljs-string\">&#x27;&#x3C;/li&#x3E;&#x3C;li&#x3E;&#x27;</span>) + <span class=\"hljs-string\">&#x27;&#x3C;/li&#x3E;&#x3C;/ul&#x3E;&#x27;</span> : <span class=\"hljs-string\">&#x27;&#x3C;ul&#x3E;&#x3C;/ul&#x3E;&#x27;</span>;\n}\n</code></pre>\n<p>You could render the view and continue execution once the view has been rendered onto a <code class=\"hljs\">div</code> by listening to the <code class=\"hljs\">&#x27;render&#x27;</code> event at the view level.</p>\n<pre><code class=\"hljs javascript\">taunus.partial(div, <span class=\"hljs-string\">&#x27;tags&#x27;</span>, [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]).on(<span class=\"hljs-string\">&#x27;render&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">html</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Here\\&#x27;s the HTML that was rendered on our div\\n&#x27;</span> + html);\n});\n</code></pre>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.navigate(url, options)</code></h2>\n<p>Whenever you want to navigate to a URL, say when an AJAX call finishes after a button click, you can use <code class=\"hljs\">taunus.navigate</code> passing it a plain URL or anything that would cause <code class=\"hljs\">taunus.route(url)</code> to return a valid route.</p>\n<p>By default, if <code class=\"hljs\">taunus.navigate(url, options)</code> is called with an <code class=\"hljs\">url</code> that doesn&#x27;t match any client-side route, then the user will be redirected via <code class=\"hljs\">location.href</code>. In cases where the browser doesn&#x27;t support the history API, <code class=\"hljs\">location.href</code> will be used as well.</p>\n<p>There&#x27;s a few options you can use to tweak the behavior of <code class=\"hljs\">taunus.navigate</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">context</code></td>\n<td>A DOM element that caused the navigation event, used when emitting events</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">strict</code></td>\n<td>If set to <code class=\"hljs\">true</code> and the URL doesn&#x27;t match any route, then the navigation attempt must be ignored</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">scroll</code></td>\n<td>When this is set to <code class=\"hljs\">false</code>, elements aren&#x27;t scrolled into view after navigation</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">force</code></td>\n<td>Unless this is set to <code class=\"hljs\">true</code>, navigation won&#x27;t <em>fetch a model</em> if the route matches the current route, and <code class=\"hljs\">state.model</code> will be reused instead</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">replaceState</code></td>\n<td>Use <code class=\"hljs\">replaceState</code> instead of <code class=\"hljs\">pushState</code> when changing history</td>\n</tr>\n</tbody>\n</table>\n<p>Note that the notion of <em>fetching a model</em> might be deceiving as the model could be pulled from the cache even if <code class=\"hljs\">force</code> is set to <code class=\"hljs\">true</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.route(url)</code></h2>\n<p>This convenience method allows you to break down a URL into its individual components. The method accepts any of the following URL patterns, and it returns a Taunus route object.</p>\n<ul>\n<li>A fully qualified URL on the same origin, e.g <code class=\"hljs\">http://taunus.io/api</code></li>\n<li>An absolute URL without an origin, e.g <code class=\"hljs\">/api</code></li>\n<li>Just a hash, e.g <code class=\"hljs\">#foo</code> <em>(<code class=\"hljs\">location.href</code> is used)</em></li>\n<li>Falsy values, e.g <code class=\"hljs\">null</code> <em>(<code class=\"hljs\">location.href</code> is used)</em></li>\n</ul>\n<p>Relative URLs are not supported <em>(anything that doesn&#x27;t have a leading slash)</em>, e.g <code class=\"hljs\">files/data.json</code>. Anything that&#x27;s not on the same origin or doesn&#x27;t match one of the registered routes is going to yield <code class=\"hljs\">null</code>.</p>\n<p><em>This method is particularly useful when debugging your routing tables, as it gives you direct access to the router used internally by Taunus.</em></p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h4><code class=\"hljs\">taunus.route.equals(route, route)</code></h4>\n<p>Compares two routes and returns <code class=\"hljs\">true</code> if they would fetch the same model. Note that different URLs may still return <code class=\"hljs\">true</code>. For instance, <code class=\"hljs\">/foo</code> and <code class=\"hljs\">/foo#bar</code> would fetch the same model even if they&#x27;re different URLs. That&#x27;s because the hash portion of an URL is never sent to the server.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.redirect(options)</code></h2>\n<p>Redirects the user to a different URL. If <code class=\"hljs\">hard</code> is set to <code class=\"hljs\">true</code>, then this method is effectively the same as doing <code class=\"hljs\">location.href = options.href</code>. If <code class=\"hljs\">hard</code> is <code class=\"hljs\">false</code>, <a href=\"#-taunus-navigate-url-options-\">taunus.navigate</a> will be used.</p>\n<h6>Example</h6>\n<pre><code class=\"hljs javascript\">taunus.redirect({ href: <span class=\"hljs-string\">&#x27;/foo&#x27;</span>, hard: <span class=\"hljs-literal\">true</span> });\n</code></pre>\n<p>When the <code class=\"hljs\">force</code> option is set to <code class=\"hljs\">true</code>, redirects will be carried out even if the target URL is the same as the current <code class=\"hljs\">location</code>.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.resolve</code> on the client</h2>\n<p>This method is identical to the server-side flavor of <a href=\"#-taunus-resolve-action-data-\"><code class=\"hljs\">taunus.resolve(action, data)</code></a>, but available on the client-side.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.state</code></h2>\n<p>This is an internal state variable, and it contains a lot of useful debugging information.</p>\n<ul>\n<li><code class=\"hljs\">container</code> is the DOM element passed to <code class=\"hljs\">taunus.mount</code></li>\n<li><code class=\"hljs\">controllers</code> are all the controllers, as defined in the wiring module</li>\n<li><code class=\"hljs\">templates</code> are all the templates, as defined in the wiring module</li>\n<li><code class=\"hljs\">routes</code> are all the routes, as defined in the wiring module</li>\n<li><code class=\"hljs\">route</code> is a reference to the current route</li>\n<li><code class=\"hljs\">model</code> is a reference to the model used to render the current view</li>\n<li><code class=\"hljs\">prefetch</code> exposes whether prefetching is turned on</li>\n<li><code class=\"hljs\">cache</code> exposes whether caching is enabled</li>\n<li><code class=\"hljs\">version</code> exposes the version string that&#x27;s currently in use</li>\n</ul>\n<p>There&#x27;s also a <code class=\"hljs\">clear</code> method accessible through <code class=\"hljs\">taunus.state.clear</code>, which will empty the cache, as well as remove from the <code class=\"hljs\">state</code> any controllers and templates that were lazy loaded.</p>\n<p>Of course, you&#x27;re not supposed to meddle with it, so be a good citizen and just inspect its values!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2><code class=\"hljs\">taunus.xhr(url, options?, done)</code></h2>\n<p>This method allows you to issue your own AJAX requests through the <code class=\"hljs\">xhr</code> module. It sets a few convenient defaults, <em>listed below</em>, where <code class=\"hljs\">url</code> refers to the URL passed as the first parameter.</p>\n<pre><code class=\"hljs javascript\">{\n  url: url,\n  json: <span class=\"hljs-literal\">true</span>,\n  headers: { Accept: <span class=\"hljs-string\">&#x27;application/json&#x27;</span> }\n}\n</code></pre>\n<p>The <code class=\"hljs\">done(err, body, res)</code> callback will be invoked when the request finishes, and it&#x27;ll be passed three parameters, an optional error if something went wrong <em>(request failed, was aborted, etc.)</em> and a <code class=\"hljs\">body</code> parameter containing the response body. The raw <code class=\"hljs\">res</code> object that&#x27;s typically provided by <a href=\"https://github.com/Raynos/xhr\"><code class=\"hljs\">xhr</code></a> as the second parameter is provided as the third parameter instead.</p>\n<p>As an example, here is a <code class=\"hljs\">GET</code> request.</p>\n<pre><code class=\"hljs javascript\">taunus.xhr(<span class=\"hljs-string\">&#x27;/api/places&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, body</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(body);\n  <span class=\"hljs-comment\">// &#x3C;- { places: [&#x27;underwater fortress&#x27;, &#x27;island mansion&#x27;] }</span>\n});\n</code></pre>\n<p>Always remember to handle the case where <code class=\"hljs\">err</code> is set!</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>Using <code class=\"hljs\">taunus.prefetch(url, element)</code></h1>\n<p>The prefetcher API allows you to start fetching an <code class=\"hljs\">url</code>, provided that it matches a known Taunus view route and that <a href=\"#caching\">the cache</a> is enabled. The <code class=\"hljs\">element</code> is used mostly as context during event emission, and it can be useful for debugging as well.</p>\n<p>Use cases for prefetching are further discussed in the <a href=\"/performance#enable-prefetching-for-predictive-cache-loading\">Performance Optimization</a> guide.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h2>Debugging Taunus</h2>\n<p>On the client-side, you will typically <code class=\"hljs\">require</code> Taunus using the statement below.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> taunus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus&#x27;</span>);\n</code></pre>\n<p>However, you could also turn on the internal debug logger simply by using another entry point!</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> taunus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;taunus/browser/debug&#x27;</span>);\n</code></pre>\n<p>The screenshot below contains an example of this mechanism, where using <a href=\"#-taunus-partial-container-action-model-\"><code class=\"hljs\">taunus.partial</code></a> triggers a flurry of debug messages.</p>\n<p><img src=\"http://i.imgur.com/CjbIHy0.png\" alt=\"debug.png\"/></p>\n<p>This is particularly helpful during development, but also useful if you don&#x27;t understand exactly how Taunus is doing something, as the logger is pretty verbose.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>Client-Side Controllers</h1>\n<p>Client-side controllers are executed right after a view is rendered, even in the case of <a href=\"#-taunus-partial-container-action-model-\">partial views</a>. These controllers are used to progressively add behavior on top of the HTML for that view.</p>\n<p>View controllers take three parameters.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"hljs\">model</code></td>\n<td>Model that was used to render the view</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">container</code></td>\n<td>The DOM element where the view was rendered</td>\n</tr>\n<tr>\n<td><code class=\"hljs\">route?</code></td>\n<td>Route that triggered the rendering engine. May be <code class=\"hljs\">null</code></td>\n</tr>\n</tbody>\n</table>\n<p>Note that Taunus will <a href=\"#-taunus-on-type-fn-\">emit a <code class=\"hljs\">render</code> event</a> right before the view controller gets executed, giving you a chance to react to views getting rendered.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n<h1>The <code class=\"hljs\">.taunusrc</code> manifest</h1>\n<p>If you want to use values other than the conventional defaults shown in the table below, then you should create a <code class=\"hljs\">.taunusrc</code> file. Note that the defaults need to be overwritten in a case-by-case basis. These options can also be configured in your <code class=\"hljs\">package.json</code>, under the <code class=\"hljs\">taunus</code> property.</p>\n<pre><code class=\"hljs json\">{\n  &#x22;<span class=\"hljs-attribute\">views</span>&#x22;: <span class=\"hljs-value\"><span class=\"hljs-string\">&#x22;.bin/views&#x22;</span></span>,\n  &#x22;<span class=\"hljs-attribute\">server_routes</span>&#x22;: <span class=\"hljs-value\"><span class=\"hljs-string\">&#x22;controllers/routes.js&#x22;</span></span>,\n  &#x22;<span class=\"hljs-attribute\">server_controllers</span>&#x22;: <span class=\"hljs-value\"><span class=\"hljs-string\">&#x22;controllers&#x22;</span></span>,\n  &#x22;<span class=\"hljs-attribute\">client_controllers</span>&#x22;: <span class=\"hljs-value\"><span class=\"hljs-string\">&#x22;client/js/controllers&#x22;</span></span>,\n  &#x22;<span class=\"hljs-attribute\">client_wiring</span>&#x22;: <span class=\"hljs-value\"><span class=\"hljs-string\">&#x22;.bin/wiring.js&#x22;</span>\n</span>}\n</code></pre>\n<ul>\n<li>The <code class=\"hljs\">views</code> directory is where your views <em>(already compiled into JavaScript)</em> are placed. These views are used directly on both the server-side and the client-side</li>\n<li>The <code class=\"hljs\">server_routes</code> file is the module where you export a collection of routes. The CLI will pull these routes when creating the client-side routes for the wiring module</li>\n<li>The <code class=\"hljs\">server_controllers</code> directory is the root directory where your server-side controllers live. It&#x27;s used when setting up the server-side router</li>\n<li>The <code class=\"hljs\">client_controllers</code> directory is where your client-side controller modules live. The CLI will <code class=\"hljs\">require</code> these controllers in its resulting wiring module</li>\n<li>The <code class=\"hljs\">client_wiring</code> file is where your wiring module will be placed by the CLI. You&#x27;ll then have to <code class=\"hljs\">require</code> it in your application when booting up Taunus</li>\n</ul>\n<p>Here is where things get <a href=\"http://en.wikipedia.org/wiki/Convention_over_configuration\">a little conventional</a>. Views, and both server-side and client-side controllers are expected to be organized by following the <code class=\"hljs\">{root}/{controller}/{action}</code> pattern, but you could change that using <code class=\"hljs\">resolvers</code> when invoking the CLI and using the server-side API.</p>\n<p>Views and controllers are also expected to be CommonJS modules that export a single method.</p>\n<p><sub><a href=\"#table-of-contents\"><em>(back to table of contents)</em></a></sub></p>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # API Documentation\n\n    Here's the API documentation for Taunus. If you've never used it before, we recommend going over the [Getting Started][1] guide before jumping into the API documentation. That way, you'll get a better idea of what to look for and how to put together simple applications using Taunus, before going through documentation on every public interface to Taunus.\n\n    Taunus exposes _three different public APIs_, and there's also **plugins to integrate Taunus and an HTTP server**. This document covers all three APIs extensively. If you're concerned about the inner workings of Taunus, please refer to the [Getting Started][1] guide. This document aims to only cover how the public interface affects application state, but **doesn't delve into implementation details**.\n\n    # Table of Contents\n\n    - A [server-side API](#server-side-api) that deals with server-side rendering\n      - The [`taunus.mount`](#-taunus-mount-addroute-options-) method\n        - Its [`options`](#the-options-object) argument\n          - [`layout`](#-options-layout-)\n          - [`routes`](#-options-routes-)\n          - [`getDefaultViewModel`](#-options-getdefaultviewmodel-)\n          - [`plaintext`](#-options-plaintext-)\n          - [`resolvers`](#-options-resolvers-)\n          - [`version`](#-options-version-)\n          - [`deferMinified`](#-options-deferminified-)\n        - Its [`addRoute`](#-addroute-definition-) argument\n      - The [`taunus.render`](#-taunus-render-action-viewmodel-req-res-next-) method\n      - The [`taunus.resolve`](#-taunus-resolve-action-data-) method\n      - The [`taunus.redirect`](#-taunus-redirect-req-res-url-options-) method\n      - The [`taunus.rebuildDefaultViewModel`](#-taunus-rebuilddefaultviewmodel-done-) method\n    - [Server-side controllers](#server-side-controllers)\n    - A [suite of plugins](#http-framework-plugins) can integrate Taunus and an HTTP server\n      - Using [`taunus-express`](#using-taunus-express-) for [Express][2]\n      - Using [`taunus-hapi`](#using-taunus-hapi-) for [Hapi][3]\n    - A [CLI that produces a wiring module](#command-line-interface) for the client-side\n      - The [`--output`](#-output-) flag\n      - The [`--watch`](#-watch-) flag\n      - The [`--transform <module>`](#-transform-module-) flag\n      - The [`--defer`](#-defer-actions-) flag\n      - The [`--resolvers <module>`](#-resolvers-module-) flag\n      - The [`--bundle`](#-bundle-) flag\n    - A [client-side API](#client-side-api) that deals with client-side rendering\n      - The [`taunus.mount`](#-taunus-mount-container-wiring-options-) method\n        - Using the [`auto`](#using-the-auto-strategy) strategy\n        - Using the [`inline`](#using-the-inline-strategy) strategy\n        - Using the [`manual`](#using-the-manual-strategy) strategy\n        - [Caching](#caching)\n        - [Prefetching](#prefetching)\n        - [Versioning](#versioning)\n      - The [`taunus.on`](#-taunus-on-type-fn-) method\n      - The [`taunus.once`](#-taunus-once-type-fn-) method\n      - The [`taunus.off`](#-taunus-off-type-fn-) method\n      - The [`taunus.intercept`](#-taunus-intercept-action-fn-) method\n      - The [`taunus.partial`](#-taunus-partial-container-action-model-) method\n      - The [`taunus.navigate`](#-taunus-navigate-url-options-) method\n      - The [`taunus.route`](#-taunus-route-url-) method\n        - The [`taunus.route.equals`](#-taunus-route-equals-route-route-) method\n      - The [`taunus.redirect`](#-taunus-redirect-options-) method\n      - The [`taunus.resolve`](#-taunus-resolve-on-the-client) method\n      - The [`taunus.state`](#-taunus-state-) property\n      - The [`taunus.xhr`](#-taunus-xhr-url-options-done-) method\n      - The [`taunus.prefetch`](#using-taunus-prefetch-url-element-) method\n      - [Debugging Taunus](#debugging-taunus)\n    - [Client-side controllers](#client-side-controllers)\n    - The [`.taunusrc`](#the-taunusrc-manifest) manifest\n\n    # Server-side API\n\n    The server-side API is used to set up the view router. It then gets out of the way, allowing the client-side to eventually take over and add any extra sugar on top, _including client-side rendering_.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.mount(addRoute, options?)`\n\n    Mounts Taunus on top of a server-side router, by registering each route in `options.routes` with the `addRoute` method.\n\n    > Note that most of the time, **this method shouldn't be invoked directly**, but rather through one of the [HTTP framework plugins](#http-framework-plugins) presented below.\n\n    Here's an incomplete example of how this method may be used. It is incomplete because route definitions have more options beyond the `route` and `action` properties.\n\n    ```js\n    'use strict';\n\n    taunus.mount(addRoute, {\n      routes: [{ route: '/', action: 'home/index' }]\n    });\n\n    function addRoute (definition) {\n      app.get(definition.route, definition.action);\n    }\n    ```\n\n    Let's go over the options you can pass to `taunus.mount` first.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### The `options?` object\n\n    There's a few options that can be passed to the server-side mountpoint. You're probably going to be passing these to your [HTTP framework plugin](#http-framework-plugins), rather than using `taunus.mount` directly.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.layout?`\n\n    The `layout` property is expected to have the `function(data)` signature. It'll be invoked whenever a full HTML document needs to be rendered, and a `data` object will be passed to it. That object will contain everything you've set as the view model, plus a `partial` property containing the raw HTML of the rendered partial view. Your `layout` method will typically wrap the raw HTML for the partial with the bare bones of an HTML document. Check out [the `layout.jade` used in Pony Foo][4] as an example.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.routes`\n\n    The other big option is `routes`, which expects a collection of route definitions. Route definitions use a number of properties to determine how the route is going to behave.\n\n    Here's an example route that uses the [Express][2] routing scheme.\n\n    ```js\n    {\n      route: '/articles/:slug',\n      action: 'articles/article',\n      ignore: false,\n      cache: <inherit>\n    }\n    ```\n\n    - `route` is a route in the format your HTTP framework of choice understands\n    - `action` is the name of your controller action. It'll be used to find the server-side controller, the default view that should be used with this route, and the client-side controller\n    - `cache` can be used to determine the client-side caching behavior in this application path, and it'll default to inheriting from the options passed to `taunus.mount` _on the client-side_\n    - `ignore` is used in those cases where you want a URL to be ignored by the client-side router even if there's a catch-all route that would match that URL\n\n    As an example of the `ignore` use case, consider the routing table shown below. The client-side router doesn't know _(and can't know unless you point it out)_ what routes are server-side only, and it's up to you to point those out.\n\n    ```js\n    [\n      { route: '/', action: '/home/index' },\n      { route: '/feed', ignore: true },\n      { route: '/*', action: 'error/not-found' }\n    ]\n    ```\n\n    This step is necessary whenever you have an anchor link pointed at something like an RSS feed. The `ignore` property is effectively telling the client-side _\"don't hijack links containing this URL\"_.\n\n    Please note that external links are never hijacked. Only same-origin links containing a URL that matches one of the routes will be hijacked by Taunus. External links don't need to be `ignore`d.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.getDefaultViewModel?`\n\n    The `getDefaultViewModel(done)` property can be a method that puts together the base view model, which will then be extended on an action-by-action basis. When you're done creating a view model, you can invoke `done(null, model)`. If an error occurs while building the view model, you should call `done(err)` instead.\n\n    Taunus will throw an error if `done` is invoked with an error, so you might want to put safeguards in place as to avoid that from happenning. The reason this method is asynchronous is because you may need database access or somesuch when putting together the defaults. The reason this is a method and not just an object is that the defaults may change due to human interaction with the application, and in those cases [the defaults can be rebuilt](#taunus-rebuilddefaultviewmodel).\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.plaintext?`\n\n    The `plaintext` options object is passed directly to [hget][5], and it's used to [tweak the plaintext version][6] of your site.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.resolvers?`\n\n    Resolvers are used to determine the location of some of the different pieces of your application. Typically you won't have to touch these in the slightest.\n\n    Signature                     | Description\n    ------------------------------|------------------------------------------------------\n    `getServerController(action)` | Return path to server-side controller action handler module\n    `getView(action)`             | Return path to view template module\n\n    The `addRoute` method passed to `taunus.mount` on the server-side is mostly going to be used internally by the HTTP framework plugins, so feel free to skip over the following section.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.version?`\n\n    Refer to the [Versioning](#versioning) section.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.getPartial?`\n\n    By default, Taunus will render partials on the server-side by looking up the module for an action method, and calling that action passing in a model.\n\n    You can override the default behavior by setting `options.getPartial` to a function. This method takes three parameters.\n\n    - `action` is the action that needs to be rendered\n    - `model` is the model you can use to render the view for that action\n    - `done(err, html)` is called when you're done, passing in the resulting `html` for the partial\n\n    Note that if you don't set `getPartial`, Taunus will just require your controller action method and invoke that instead.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ###### `options.deferMinified?`\n\n    When views and controllers are lazily loaded, they are compiled and bundled using Browserify. Taunus will even produce a source map. To avoid the source map, and minify the bundle instead, set `deferMinified` to `true`.\n\n    You'll probably want to set `deferMinified` to whether the application is running on the production environment.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### `addRoute(definition)`\n\n    The `addRoute(definition)` method will be passed a route definition, containing the following properties. This method is expected to register a route in your HTTP framework's router.\n\n    - `route` is the route that you set as `definition.route`\n    - `action` is the action as passed to the route definition\n    - `actionFn` will be the controller for this action method\n    - `middleware` will be an array of methods to be executed before `actionFn`\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.render(action, viewModel, req, res, next)`\n\n    This method is almost an implementation detail as you should be using Taunus through one of the plugins anyways, so we won't go very deep into it.\n\n    The render method is what Taunus uses to render views by constructing HTML, JSON, or plaintext responses. The `action` property determines the default view that will be rendered. The `viewModel` will be extended by [the default view model](#-options-getdefaultviewmodel-), and it may also override the default `action` by setting `viewModel.model.action`.\n\n    The `req`, `res`, and `next` arguments are expected to be the Express routing arguments, but they can also be mocked _(which is in fact what the Hapi plugin does)_.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.rebuildDefaultViewModel(done?)`\n\n    Once Taunus has been mounted, calling this method will rebuild the view model defaults using the `getDefaultViewModel` that was passed to `taunus.mount` in the options. An optional `done` callback will be invoked when the model is rebuilt.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.resolve(action, data?)`\n\n    Returns the first route that matches an `action`, replacing named parameters with data from the `data` object. If a matching route is not found, `null` is returned.\n\n    > If a route is matched but a required named parameter isn't in `data`, **an exception will be thrown**.\n\n    This method is most useful when composing the URL for a redirect or an action link within a template, as a means to keep the route declaration isolated from the route itself. If the route changes, the method will reflect the newer route as long as the parameters stay the same, resulting in increased maintainability. _The method is available in both layout templates and partial view templates._\n\n    ###### Example\n\n    ```js\n    taunus.resolve('projects/project', {\n      name: 'puppies', organization: 'caniuse'\n    });\n    // <- /p/caniuse/puppies\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.redirect(req, res, url, options?)`\n\n    Redirects the response to a different URL. If the request accepts HTML, this method is equivalent to `res.redirect(url)`. If the request accepts JSON, a specially crafted JSON response will trigger a client-side redirect using [taunus.navigate](#-taunus-navigate-url-options-).\n\n    Option  | Description\n    --------|--------------------------------------------------------------------------------\n    `hard`  | Uses a full page redirect when `true`\n    `force` | Client-side redirects will be carried out even if the target URL is the same as the current `location`\n\n    ###### Example\n\n    ```js\n    taunus.redirect(req, res, '/login');\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Server-Side Controllers\n\n    On the server-side, controllers are modules that export a single function. The parameters passed to these controllers depend on the server-side HTTP framework that's being used.\n\n    For example, Express gives us three parameters: `req`, `res` and `next`. Hapi gives us two instead: `request` and `reply`.\n\n    Here's a sample controller using `taunus-express`, as [detailed below](#using-taunus-express-). This is a very simple controller where we are setting the special `viewModel` property on the response, and calling `next`. Suppose this controller is the `product/home` action handler.\n\n    ```js\n    module.exports = function (req, res, next) {\n      res.viewModel = {\n        model: {\n          title: 'view title'\n        }\n      };\n      next();\n    };\n    ```\n\n    As you can see, Taunus won't alter the API provided by Express. Instead, it builds upon the notion of using middleware. Once the `product/home` view is rendered and JavaScript loads, the `product/home` view controller is executed on the client-side.\n\n    You could change the view to be rendered by setting the `action` property on the `model`. In the example shown below this would mean that the `error/offline` view would be rendered. The client-side controller will be that of `error/offline`, as well. View controllers are tied to the view that gets rendered.\n\n    ```js\n    module.exports = function (req, res, next) {\n      res.viewModel = {\n        model: {\n          title: 'view title'\n        }\n      };\n      if (offline) {\n        res.viewModel.model.action = 'error/offline';\n      }\n      next();\n    };\n    ```\n\n    Having a default action and the ability to redirect to another gives us a lot of flexibility when determining how to respond to a request.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # HTTP Framework Plugins\n\n    There's currently two different HTTP frameworks _([Express][2] and [Hapi][3])_ that you can readily use with Taunus without having to deal with any of the route plumbing yourself.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Using `taunus-express`\n\n    The `taunus-express` plugin is probably the easiest to use, as Taunus was originally developed with just [Express][2] in mind. In addition to the options already outlined for [taunus.mount](#-taunus-mount-addroute-options-), you can add middleware for any route individually.\n\n    - `middleware` are any methods you want Taunus to execute as middleware in Express applications\n\n    To get `taunus-express` going you can use the following piece of code, provided that you come up with an `options` object.\n\n    ```js\n    'use strict';\n\n    var taunus = require('taunus');\n    var taunusExpress = require('taunus-express');\n    var express = require('express');\n    var app = express();\n    var options = {\n      // ...\n    };\n\n    taunusExpress(taunus, app, options);\n    ```\n\n    The `taunusExpress` method will merely set up Taunus and add the relevant routes to your Express application by calling `app.get` a bunch of times. You can [find taunus-express on GitHub][7].\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Using `taunus-hapi`\n\n    The `taunus-hapi` plugin is a bit more involved, and you'll have to create a Pack in order to use it. In addition to [the options we've already covered](#-taunus-mount-addroute-options-), you can add `config` on any route.\n\n    - `config` is passed directly into the route registered with Hapi, giving you the most flexibility\n\n    To get `taunus-hapi` going you can use the following piece of code, and you can bring your own `options` object.\n\n    ```js\n    'use strict';\n\n    var Hapi = require('hapi');\n    var taunus = require('taunus');\n    var taunusHapi = require('taunus-hapi')(taunus);\n    var pack = new Hapi.Pack();\n\n    pack.register({\n      plugin: taunusHapi,\n      options: {\n        // ...\n      }\n    });\n    ```\n\n    The `taunusHapi` plugin will mount Taunus and register all of the necessary routes. You can [find taunus-hapi on GitHub][8].\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Command-Line Interface\n\n    Once you've set up the server-side to render your views using Taunus, it's only logical that you'll want to render the views in the client-side as well, effectively converting your application into a single-page application after the first view has been rendered on the server-side.\n\n    The Taunus CLI is an useful intermediary in the process of getting the configuration you wrote so far for the server-side to also work well in the client-side.\n\n    Install it globally for development, but remember to use local copies for production-grade uses.\n\n    ```shell\n    npm install -g taunus\n    ```\n\n    When invoked without any arguments, the CLI will simply follow the default conventions to find your route definitions, views, and client-side controllers.\n\n    ```shell\n    taunus\n    ```\n\n    By default, the output will be printed to the standard output, making for a fast debugging experience. Here's the output if you just had a single `home/index` route, and the matching view and client-side controller existed.\n\n    ```js\n    'use strict';\n\n    var templates = {\n      'home/index': require('./views/home/index.js')\n    };\n\n    var controllers = {\n      'home/index': require('../client/js/controllers/home/index.js')\n    };\n\n    var routes = [\n      {\n        route: '/',\n        action: 'home/index'\n      }\n    ];\n\n    module.exports = {\n      templates: templates,\n      controllers: controllers,\n      routes: routes\n    };\n    ```\n\n    You can use a few options to alter the outcome of invoking `taunus`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--output`\n\n    <sub>the `-o` alias is available</sub>\n\n    Output is written to a file instead of to standard output. The file path used will be the `client_wiring` option in [`.taunusrc`](#the-taunusrc-manifest), which defaults to `'.bin/wiring.js'`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--watch`\n\n    <sub>the `-w` alias is available</sub>\n\n    Whenever a server-side route definition changes, the output is printed again to either standard output or a file, depending on whether `--output` was used.\n\n    The program won't exit.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--transform <module>`\n\n    <sub>the `-t` alias is available</sub>\n\n    This flag allows you to transform server-side routes into something the client-side understands. Express routes are completely compatible with the client-side router, but Hapi routes need to be transformed using the [`hapiify`][9] module.\n\n    ```shell\n    npm install hapiify\n    taunus -t hapiify\n    ```\n\n    Using this transform relieves you from having to define the same routes twice using slightly different formats that convey the same meaning.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--defer [actions]`\n\n    <sub>the `-d` alias is available</sub>\n\n    Here is where things get interesting. The `--defer` flag allows you to defer loading for zero or more actions. Excluding the controller and view templates for any deferred action can significantly reduce the fingerprint of your application.\n\n    The `[actions]` argument determines what actions get deferred, and which don't. It expects a comma-separated list of actions, where you can pass in either the controller name, or both the controller name and the action name. Using `?` acts as a wildcard.\n\n    For example, using `admin` _(equivalent to using `admin/?`)_ will defer every action under the `admin` controller. Using `admin/nuke` will only defer the `admin/nuke` action. If you omit the `[actions]` parameter entirely, the default value of `'?'` will be used and everything will be deferred.\n\n    When components get deferred, they'll be loaded as soon as Taunus detects that they're needed. This can happen in a few places.\n\n    - The user navigates to (or [_prefetches_](#prefetching)) the `/admin` route, and `admin/index` was deferred, and its components aren't cached on the client-side yet\n    - A controller uses `taunus.partial` to render an action that was deferred, and its components aren't cached on the client-side yet\n    - The user navigates to the `/admin` route, and its matching `admin/index` route wasn't deferred, but the server-side controller decides to change the action to `admin/superadmin`. When the response gets to the client, it'll need to ask the server for the `admin/superadmin` template if the client doesn't already have it\n\n    You don't have to worry about those different scenarios, though, as Taunus handles them all for you transparently. You should [learn more about deferred loading on the Performance Optimization guide][20].\n\n    > A possible concern with deferred execution is that partial views may not be rendered immediately, as a request may be necessary to fetch the controller or template for the partial.\n\n    Some other considerations, regarding how deferred components get bundled, are listed in the [Performance Optimization][20] guide.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--resolvers <module>`\n\n    <sub>the `-r` alias is available</sub>\n\n    Similarly to the [`resolvers`](#-options-resolvers-) option that you can pass to [`taunus.mount`](#-taunus-mount-addroute-options-), these resolvers can change the way in which file paths are resolved.\n\n    Signature                     | Description\n    ------------------------------|------------------------------------------------------\n    `getClientController(action)` | Return path to client-side controller action handler module\n    `getView(action)`             | Return path to view template module\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `--bundle`\n\n    <sub>the `-b` alias is available</sub>\n\n    Under this experimental flag, the CLI will use Browserify to compile a standalone module that includes the wiring normally exported by the CLI plus all of Taunus [as a UMD module][10].\n\n    This allows you to use Taunus on the client-side even if you don't want to use [Browserify][11] directly.\n\n    Feedback and suggestions about this flag, _and possible alternatives that would make Taunus easier to use_, are welcome.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Client-side API\n\n    Just like the server-side, everything in the client-side begins at the mountpoint. Once the application is mounted, anchor links will be hijacked and the client-side router will take over view rendering. Client-side controllers are executed whenever a view is rendered.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.mount(container, wiring, options?)`\n\n    The mountpoint takes a root container, the wiring module, and an options parameter. The `container` is where client-side-rendered views will be placed, by replacing whatever HTML contents already exist. You can pass in the `wiring` module exactly as built by the CLI, and no further configuration is necessary.\n\n    When the mountpoint executes, Taunus will configure its internal state, _set up the client-side router_, run the client-side controller for the server-side rendered view, and start hijacking links.\n\n    As an example, consider a browser makes a `GET` request for `/articles/the-fox` for the first time. Once `taunus.mount(container, wiring)` is invoked on the client-side, several things would happen in the order listed below.\n\n    - Taunus sets up the client-side view routing engine\n    - If enabled _(via `options`)_, the caching engine is configured\n    - Taunus obtains the view model _(more on this later)_\n    - When a view model is obtained, the `'start'` event is emitted\n    - Anchor links start being monitored for clicks _(at this point your application becomes a [SPA][13])_\n    - The `articles/article` client-side controller is executed\n\n    That's quite a bit of functionality, but if you think about it, most other frameworks also render the view at this point, _rather than on the server-side!_\n\n    In order to better understand the process, I'll walk you through the `options` parameter.\n\n    First off, the `bootstrap` option determines the strategy used to pull the view model of the server-side rendered view into the client-side. There are three possible strategies available: `auto` _(the default strategy)_, `inline`, or `manual`. The `auto` strategy involves the least work, which is why it's the default.\n\n    - `auto` will make an AJAX request for the view model\n    - `inline` expects you to place the model into a `<script type='text/taunus'>` tag\n    - `manual` expects you to get the view model however you want to, and then let Taunus know when it's ready\n\n    Let's go into detail about each of these strategies.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `auto` strategy\n\n    The `auto` strategy means that Taunus will make use of an AJAX request to obtain the view model. _You don't have to do anything else_ and this is the default strategy. This is the **most convenient strategy, but also the slowest** one.\n\n    It's slow because the view model won't be requested until the bulk of your JavaScript code has been downloaded, parsed, executed, and `taunus.mount` is invoked.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `inline` strategy\n\n    The `inline` strategy expects you to add a `data-taunus` attribute on the `container` element. This attribute must be equal to the `id` attribute of a `<script>` tag containing the serialized view model alongside the version information automatically injected by Taunus into the layout template data.\n\n    ```jade\n    div(data-taunus='model')!=partial\n    script#model(type='text/taunus')=JSON.stringify({ version: version, model: model })\n    ```\n\n    Pay special attention to the fact that the model is not only made into a JSON string, _but also HTML encoded by Jade_. When Taunus extracts the model from the `<script>` tag it'll unescape it, and then parse it as JSON.\n\n    This strategy is also fairly convenient to set up, but it involves a little more work. It might be worthwhile to use in cases where models are small, but it will slow down server-side view rendering, as the model is inlined alongside the HTML.\n\n    That means that the content you are supposed to be prioritizing is going to take longer to get to your humans, but once they get the HTML, this strategy will execute the client-side controller almost immediately.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Using the `manual` strategy\n\n    The `manual` strategy is the most involved of the three, but also the most performant. In this strategy you're supposed to add the following _(seemingly pointless)_ snippet of code in a `<script>` other than the one that's pulling down Taunus, so that they are pulled concurrently rather than serially.\n\n    ```js\n    'use strict';\n\n    window.taunusReady = function (model) {\n      window.taunusReady = model;\n    };\n    ```\n\n    Once you somehow get your hands on the view model, you should invoke `taunusReady(model)`. Considering you'll be pulling both the view model and Taunus at the same time, a number of different scenarios may play out.\n\n    - The view model is loaded first, you call `taunusReady(model)` and wait for Taunus to take the model object and boot the application as soon as `taunus.mount` is executed\n    - Taunus loads first and `taunus.mount` is called first. In this case, Taunus will replace `window.taunusReady` with a special `boot` method. When the view model finishes loading, you call `taunusReady(model)` and the application finishes booting\n\n    > If this sounds a little mind-bending it's because it is. It's not designed to be pretty, but merely to be performant.\n\n    Now that we've addressed the awkward bits, let's cover the _\"somehow get your hands on the view model\"_ aspect. My preferred method is using JSONP, as it's able to deliver the smallest snippet possible, and it can take advantage of server-side caching. Considering you'll probably want this to be an inline script, keeping it small is important.\n\n    The good news is that the server-side supports JSONP out the box. Here's a snippet of code you could use to pull down the view model and boot Taunus up as soon as both operations are ready.\n\n    ```js\n    'use strict';\n\n    function inject (url) {\n      var script = document.createElement('script');\n      script.src = url;\n      document.body.appendChild(script);\n    }\n\n    function injector () {\n      var search = location.search;\n      var searchQuery = search ? '&' + search.substr(1) : '';\n      var searchJson = '?json&callback=taunusReady' + searchQuery;\n      inject(location.pathname + searchJson);\n    }\n\n    window.taunusReady = function (model) {\n      window.taunusReady = model;\n    };\n\n    injector();\n    ```\n\n    As mentioned earlier, this approach involves getting your hands dirtier but it pays off by being the fastest of the three.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Caching\n\n    The client-side in Taunus supports caching in-memory and using the embedded IndexedDB system by merely turning on the `cache` flag in the options passed to `taunus.mount` on the client-side.\n\n    If you set `cache` to `true` then cached items will be considered _\"fresh\" (valid copies of the original)_ for **15 seconds**. You can also set `cache` to a number, and that number of seconds will be used as the default instead.\n\n    Caching can also be tweaked on individual routes. For instance, you could set `{ cache: true }` when mounting Taunus and then have `{ cache: 3600 }` on a route that you want to cache for a longer period of time.\n\n    The caching layer is _seamlessly integrated_ into Taunus, meaning that any views rendered by Taunus will be cached according to these caching rules. Keep in mind, however, that persistence at the client-side caching layer will only be possible in [browsers that support IndexedDB][14]. In the case of browsers that don't support IndexedDB, Taunus will use an in-memory cache, which will be wiped out whenever the human decides to close the tab in their browser.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### Prefetching\n\n    If caching is enabled, the next logical step is prefetching. This is enabled just by adding `prefetch: true` to the options passed to `taunus.mount`. The prefetching feature will fire for any anchor link that's trips over a `mouseover` or a `touchstart` event. If a route matches the URL in the `href`, an AJAX request will prefetch the view and cache its contents, improving perceived performance.\n\n    When links are clicked before prefetching finishes, they'll wait on the prefetcher to finish before immediately switching to the view, effectively cutting down the response time. If the link was already prefetched or otherwise cached, the view will be loaded immediately. If the human hovers over a link and another one was already being prefetched, then that one is aborted. This prevents prefetching from draining the bandwidth on clients with limited or intermittent connectivity.\n\n    #### Versioning\n\n    When enabled, versioning will look out for discrepancies between what's currently on the client and what's on the server, and reload everything necessary to make what's on the client match what's on the server.\n\n    In order to turn it on, set the `version` field in the options when invoking `taunus.mount` **on both the server-side and the client-side, using the same value**. The Taunus version string will be added to the one you provided, so that Taunus will know to stay alert for changes to Taunus itself, as well.\n\n    > To make sure you don't forget to change the version string in one of the mountpoints, please create a JSON file with just the version string and `require` that file in both sides.\n    >\n    > ```shell\n    > echo '\"1.0.0\"' > version.json\n    > ```\n\n    The default version string is set to `1`. The Taunus version will be prepended to yours, resulting in a value such as `t3.0.0;v1` where Taunus is running version `3.0.0` and your application is running version `1`.\n\n    Refer to the Getting Started guide for a more detailed [analysis of the uses for versioning][15]. There's some more nuggets of information in the [Performance Optimization][18] guide as well.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.on(type, fn)`\n\n    Taunus emits a series of events during its lifecycle, and `taunus.on` is the way you can tune in and listen for these events using a subscription function `fn`.\n\n    Event            | Arguments                 | Description\n    -----------------|---------------------------|------------------------------------\n    `'start'`        | `container, model, route` | Emitted when `taunus.mount` finished the route setup and is about to invoke the client-side controller. Subscribe to this event before calling `taunus.mount`.\n    `'render'`       | `container, model, route` | A view has just been rendered and its client-side controller is about to be invoked\n    `'change'`       | `route, model`            | Same as `'render'`, but only if `container` is the mountpoint and the route has changed.\n    `'fetch.start'`  |  `route, context`         | Emitted whenever an XHR request starts.\n    `'fetch.done'`   |  `route, context, data`   | Emitted whenever an XHR request ends successfully.\n    `'fetch.abort'`  |  `route, context`         | Emitted whenever an XHR request is purposely aborted.\n    `'fetch.error'`  |  `route, context, err`    | Emitted whenever an XHR request results in an HTTP error.\n\n    Consider for instance that you'd like to keep track of every view that gets rendered, and what DOM element it gets placed into. The piece of code below would quickly do that for us.\n\n    ```js\n    taunus.on('render', function (container) {\n      console.log('Rendered a view on', container);\n    });\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.once(type, fn)`\n\n    This method is equivalent to [`taunus.on`](#-taunus-on-type-fn-), except the event listeners will be used once and then it'll be discarded.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.off(type, fn)`\n\n    Using this method you can remove any event listeners that were previously added using `.on` or `.once`. You must provide the type of event you want to remove and a reference to the event listener function that was originally used when calling `.on` or `.once`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.intercept(action?, fn)`\n\n    This method can be used to anticipate model requests, before they ever make it into XHR requests. You can add interceptors for specific actions, which would be triggered only if the request matches the specified `action`. You can also add global interceptors by omitting the `action` parameter, or setting it to `*`.\n\n    An interceptor function will receive an `event` parameter, containing a few different properties.\n\n    - `url` contains the URL that needs a view model\n    - `route` contains the full route object as you'd get from [`taunus.route(url)`](#-taunus-route-url-)\n    - `parts` is just a shortcut for `route.parts`\n    - `preventDefault(data)` allows you to suppress the need for an AJAX request, commanding Taunus to use the response data you've provided instead\n    - `defaultPrevented` tells you if some other handler has prevented the default behavior\n    - `canPreventDefault` tells you if invoking `event.preventDefault` will have any effect\n    - `data` starts as `null`, and it can later become the data passed to `preventDefault`\n\n    Interceptors are asynchronous, but if an interceptor spends longer than 50ms it'll be short-circuited and calling `event.preventDefault` past that point won't have any effect.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.partial(container, action, model)`\n\n    This method provides you with access to the view-rendering engine of Taunus. You can use it to render the `action` view into the `container` DOM element, using the specified `model`. Once the view is rendered, the `render` event will be fired _(with `container, model` as arguments)_ and the client-side controller for that view will be executed.\n\n    Note that the partial may be rendered asynchronously if the `action` is [deferred](#-defer-actions-) and its components (view template, controller) aren't readily available in the client yet. This method returns an event emitter, which you can use to guarantee that you continue exection after the partial has been rendered.\n\n    #### Example\n\n    Given a deferred `'tags'` partial view like this function:\n\n    ```js\n    function (model) {\n      return model.length ? '<ul><li>' + model.join('</li><li>') + '</li></ul>' : '<ul></ul>';\n    }\n    ```\n\n    You could render the view and continue execution once the view has been rendered onto a `div` by listening to the `'render'` event at the view level.\n\n    ```js\n    taunus.partial(div, 'tags', ['a', 'b']).on('render', function (html) {\n      console.log('Here\\'s the HTML that was rendered on our div\\n' + html);\n    });\n    ```\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.navigate(url, options)`\n\n    Whenever you want to navigate to a URL, say when an AJAX call finishes after a button click, you can use `taunus.navigate` passing it a plain URL or anything that would cause `taunus.route(url)` to return a valid route.\n\n    By default, if `taunus.navigate(url, options)` is called with an `url` that doesn't match any client-side route, then the user will be redirected via `location.href`. In cases where the browser doesn't support the history API, `location.href` will be used as well.\n\n    There's a few options you can use to tweak the behavior of `taunus.navigate`.\n\n    Option           | Description\n    -----------------|-------------------------------------------------------------------\n    `context`        | A DOM element that caused the navigation event, used when emitting events\n    `strict`         | If set to `true` and the URL doesn't match any route, then the navigation attempt must be ignored\n    `scroll`         | When this is set to `false`, elements aren't scrolled into view after navigation\n    `force`          | Unless this is set to `true`, navigation won't _fetch a model_ if the route matches the current route, and `state.model` will be reused instead\n    `replaceState`   | Use `replaceState` instead of `pushState` when changing history\n\n    Note that the notion of _fetching a model_ might be deceiving as the model could be pulled from the cache even if `force` is set to `true`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.route(url)`\n\n    This convenience method allows you to break down a URL into its individual components. The method accepts any of the following URL patterns, and it returns a Taunus route object.\n\n    - A fully qualified URL on the same origin, e.g `http://taunus.io/api`\n    - An absolute URL without an origin, e.g `/api`\n    - Just a hash, e.g `#foo` _(`location.href` is used)_\n    - Falsy values, e.g `null` _(`location.href` is used)_\n\n    Relative URLs are not supported _(anything that doesn't have a leading slash)_, e.g `files/data.json`. Anything that's not on the same origin or doesn't match one of the registered routes is going to yield `null`.\n\n    _This method is particularly useful when debugging your routing tables, as it gives you direct access to the router used internally by Taunus._\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    #### `taunus.route.equals(route, route)`\n\n    Compares two routes and returns `true` if they would fetch the same model. Note that different URLs may still return `true`. For instance, `/foo` and `/foo#bar` would fetch the same model even if they're different URLs. That's because the hash portion of an URL is never sent to the server.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.redirect(options)`\n\n    Redirects the user to a different URL. If `hard` is set to `true`, then this method is effectively the same as doing `location.href = options.href`. If `hard` is `false`, [taunus.navigate](#-taunus-navigate-url-options-) will be used.\n\n    ###### Example\n\n    ```js\n    taunus.redirect({ href: '/foo', hard: true });\n    ```\n\n    When the `force` option is set to `true`, redirects will be carried out even if the target URL is the same as the current `location`.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.resolve` on the client\n\n    This method is identical to the server-side flavor of [`taunus.resolve(action, data)`](#-taunus-resolve-action-data-), but available on the client-side.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.state`\n\n    This is an internal state variable, and it contains a lot of useful debugging information.\n\n    - `container` is the DOM element passed to `taunus.mount`\n    - `controllers` are all the controllers, as defined in the wiring module\n    - `templates` are all the templates, as defined in the wiring module\n    - `routes` are all the routes, as defined in the wiring module\n    - `route` is a reference to the current route\n    - `model` is a reference to the model used to render the current view\n    - `prefetch` exposes whether prefetching is turned on\n    - `cache` exposes whether caching is enabled\n    - `version` exposes the version string that's currently in use\n\n    There's also a `clear` method accessible through `taunus.state.clear`, which will empty the cache, as well as remove from the `state` any controllers and templates that were lazy loaded.\n\n    Of course, you're not supposed to meddle with it, so be a good citizen and just inspect its values!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## `taunus.xhr(url, options?, done)`\n\n    This method allows you to issue your own AJAX requests through the `xhr` module. It sets a few convenient defaults, _listed below_, where `url` refers to the URL passed as the first parameter.\n\n    ```js\n    {\n      url: url,\n      json: true,\n      headers: { Accept: 'application/json' }\n    }\n    ```\n\n    The `done(err, body, res)` callback will be invoked when the request finishes, and it'll be passed three parameters, an optional error if something went wrong _(request failed, was aborted, etc.)_ and a `body` parameter containing the response body. The raw `res` object that's typically provided by [`xhr`][16] as the second parameter is provided as the third parameter instead.\n\n    As an example, here is a `GET` request.\n\n    ```js\n    taunus.xhr('/api/places', function (err, body) {\n      console.log(body);\n      // <- { places: ['underwater fortress', 'island mansion'] }\n    });\n    ```\n\n    Always remember to handle the case where `err` is set!\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Using `taunus.prefetch(url, element)`\n\n    The prefetcher API allows you to start fetching an `url`, provided that it matches a known Taunus view route and that [the cache](#caching) is enabled. The `element` is used mostly as context during event emission, and it can be useful for debugging as well.\n\n    Use cases for prefetching are further discussed in the [Performance Optimization][19] guide.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    ## Debugging Taunus\n\n    On the client-side, you will typically `require` Taunus using the statement below.\n\n    ```js\n    var taunus = require('taunus');\n    ```\n\n    However, you could also turn on the internal debug logger simply by using another entry point!\n\n    ```js\n    var taunus = require('taunus/browser/debug');\n    ```\n\n    The screenshot below contains an example of this mechanism, where using [`taunus.partial`](#-taunus-partial-container-action-model-) triggers a flurry of debug messages.\n\n    ![debug.png][17]\n\n    This is particularly helpful during development, but also useful if you don't understand exactly how Taunus is doing something, as the logger is pretty verbose.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # Client-Side Controllers\n\n    Client-side controllers are executed right after a view is rendered, even in the case of [partial views](#-taunus-partial-container-action-model-). These controllers are used to progressively add behavior on top of the HTML for that view.\n\n    View controllers take three parameters.\n\n    Parameter   | Description\n    ------------|--------------------------\n    `model`     | Model that was used to render the view\n    `container` | The DOM element where the view was rendered\n    `route?`    | Route that triggered the rendering engine. May be `null`\n\n    Note that Taunus will [emit a `render` event](#-taunus-on-type-fn-) right before the view controller gets executed, giving you a chance to react to views getting rendered.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    # The `.taunusrc` manifest\n\n    If you want to use values other than the conventional defaults shown in the table below, then you should create a `.taunusrc` file. Note that the defaults need to be overwritten in a case-by-case basis. These options can also be configured in your `package.json`, under the `taunus` property.\n\n    ```json\n    {\n      \"views\": \".bin/views\",\n      \"server_routes\": \"controllers/routes.js\",\n      \"server_controllers\": \"controllers\",\n      \"client_controllers\": \"client/js/controllers\",\n      \"client_wiring\": \".bin/wiring.js\"\n    }\n    ```\n\n    - The `views` directory is where your views _(already compiled into JavaScript)_ are placed. These views are used directly on both the server-side and the client-side\n    - The `server_routes` file is the module where you export a collection of routes. The CLI will pull these routes when creating the client-side routes for the wiring module\n    - The `server_controllers` directory is the root directory where your server-side controllers live. It's used when setting up the server-side router\n    - The `client_controllers` directory is where your client-side controller modules live. The CLI will `require` these controllers in its resulting wiring module\n    - The `client_wiring` file is where your wiring module will be placed by the CLI. You'll then have to `require` it in your application when booting up Taunus\n\n    Here is where things get [a little conventional][12]. Views, and both server-side and client-side controllers are expected to be organized by following the `{root}/{controller}/{action}` pattern, but you could change that using `resolvers` when invoking the CLI and using the server-side API.\n\n    Views and controllers are also expected to be CommonJS modules that export a single method.\n\n    <sub>[_(back to table of contents)_](#table-of-contents)</sub>\n\n    [1]: /getting-started\n    [2]: http://expressjs.com\n    [3]: http://hapijs.com\n    [4]: https://github.com/ponyfoo/ponyfoo/blob/33271751312db6e92059d98293d0a7ac6e9e8e5b/views/server/layout/layout.jade\n    [5]: https://github.com/bevacqua/hget\n    [6]: https://github.com/ponyfoo/ponyfoo/blob/f6d6b5068ff03a387f503900160d9fdc1e749750/controllers/routing.js#L70-L72\n    [7]: https://github.com/taunus/taunus-express\n    [8]: https://github.com/taunus/taunus-hapi\n    [9]: https://github.com/taunus/hapiify\n    [10]: https://github.com/umdjs/umd\n    [11]: http://browserify.org\n    [12]: http://en.wikipedia.org/wiki/Convention_over_configuration\n    [13]: http://en.wikipedia.org/wiki/Single-page_application\n    [14]: http://caniuse.com/#feat=indexeddb\n    [15]: /getting-started#versioning\n    [16]: https://github.com/Raynos/xhr\n    [17]: http://i.imgur.com/CjbIHy0.png\n    [18]: /performance#use-versioning-to-ensure-cache-validity\n    [19]: /performance#enable-prefetching-for-predictive-cache-loading\n    [20]: /performance#send-views-and-controllers-to-the-client-selectively\n");
}
}